{"version":3,"file":"BigBedAdapter-qXt_mUB3.js","sources":["../../node_modules/@gmod/bbi/esm/bigbed.js","../../node_modules/@jbrowse/plugin-bed/esm/BigBedAdapter/BigBedAdapter.js"],"sourcesContent":["import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport QuickLRU from 'quick-lru';\nimport { Observable, firstValueFrom, merge } from 'rxjs';\nimport { map, reduce } from 'rxjs/operators';\nimport { BBI } from \"./bbi.js\";\nexport function filterUndef(ts) {\n    return ts.filter((t) => !!t);\n}\nexport class BigBed extends BBI {\n    constructor() {\n        super(...arguments);\n        this.readIndicesCache = new AbortablePromiseCache({\n            cache: new QuickLRU({ maxSize: 1 }),\n            fill: (args, signal) => this._readIndices({ ...args, signal }),\n        });\n    }\n    readIndices(opts = {}) {\n        const { signal, ...rest } = opts;\n        return this.readIndicesCache.get(JSON.stringify(rest), opts, signal);\n    }\n    /*\n     * retrieve unzoomed view for any scale\n     */\n    async getView(_scale, opts) {\n        return this.getUnzoomedView(opts);\n    }\n    /*\n     * parse the bigbed extraIndex fields\n     *\n     *\n     * @return a Promise for an array of Index data structure since there can be\n     * multiple extraIndexes in a bigbed, see bedToBigBed documentation\n     */\n    async _readIndices(opts) {\n        const { extHeaderOffset } = await this.getHeader(opts);\n        const b = await this.bbi.read(64, Number(extHeaderOffset));\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        // const _size = dataView.getUint16(offset, true)\n        offset += 2;\n        const count = dataView.getUint16(offset, true);\n        offset += 2;\n        const dataOffset = Number(dataView.getBigUint64(offset, true));\n        offset += 8;\n        // no extra index is defined if count==0\n        if (count === 0) {\n            return [];\n        }\n        const blocklen = 20;\n        const len = blocklen * count;\n        const buffer = await this.bbi.read(len, Number(dataOffset));\n        const indices = [];\n        for (let i = 0; i < count; i += 1) {\n            const b = buffer.subarray(i * blocklen);\n            const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n            let offset = 0;\n            const type = dataView.getInt16(offset, true);\n            offset += 2;\n            const fieldcount = dataView.getInt16(offset, true);\n            offset += 2;\n            const dataOffset = Number(dataView.getBigUint64(offset, true));\n            offset += 8 + 4; //4 skip\n            const field = dataView.getInt16(offset, true);\n            indices.push({ type, fieldcount, offset: Number(dataOffset), field });\n        }\n        return indices;\n    }\n    /*\n     * perform a search in the bigbed extraIndex to find which blocks in the\n     * bigbed data to look for the actual feature data\n     *\n     * @param name - the name to search for\n     *\n     * @param opts - a SearchOptions argument with optional signal\n     *\n     * @return a Promise for an array of bigbed block Loc entries\n     */\n    async searchExtraIndexBlocks(name, opts = {}) {\n        const indices = await this.readIndices(opts);\n        if (indices.length === 0) {\n            return [];\n        }\n        const decoder = new TextDecoder('utf8');\n        const locs = indices.map(async (index) => {\n            const { offset: offset2, field } = index;\n            const b = await this.bbi.read(32, offset2, opts);\n            const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n            let offset = 0;\n            // const _magic = dataView.getInt32(offset, true)\n            offset += 4;\n            const blockSize = dataView.getInt32(offset, true);\n            offset += 4;\n            const keySize = dataView.getInt32(offset, true);\n            offset += 4;\n            const valSize = dataView.getInt32(offset, true);\n            offset += 4;\n            // const _itemCount = Number(dataView.getBigUint64(offset, true))\n            offset += 8;\n            const bptReadNode = async (nodeOffset) => {\n                const val = Number(nodeOffset);\n                const len = 4 + blockSize * (keySize + valSize);\n                const buffer = await this.bbi.read(len, val, opts);\n                const b = buffer;\n                const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n                let offset = 0;\n                const nodeType = dataView.getInt8(offset);\n                offset += 2; //skip 1\n                const cnt = dataView.getInt16(offset, true);\n                offset += 2;\n                const keys = [];\n                if (nodeType === 0) {\n                    const leafkeys = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const key = decoder\n                            .decode(b.subarray(offset, offset + keySize))\n                            .replaceAll('\\0', '');\n                        offset += keySize;\n                        const dataOffset = Number(dataView.getBigUint64(offset, true));\n                        offset += 8;\n                        leafkeys.push({\n                            key,\n                            offset: dataOffset,\n                        });\n                    }\n                    let lastOffset = 0;\n                    for (const { key, offset } of leafkeys) {\n                        if (name.localeCompare(key) < 0 && lastOffset) {\n                            return bptReadNode(lastOffset);\n                        }\n                        lastOffset = offset;\n                    }\n                    return bptReadNode(lastOffset);\n                }\n                else if (nodeType === 1) {\n                    for (let i = 0; i < cnt; i++) {\n                        const key = decoder\n                            .decode(b.subarray(offset, offset + keySize))\n                            .replaceAll('\\0', '');\n                        offset += keySize;\n                        const dataOffset = Number(dataView.getBigUint64(offset, true));\n                        offset += 8;\n                        const length = dataView.getUint32(offset, true);\n                        offset += 4;\n                        const reserved = dataView.getUint32(offset, true);\n                        offset += 4;\n                        keys.push({\n                            key,\n                            offset: dataOffset,\n                            length,\n                            reserved,\n                        });\n                    }\n                    for (const n of keys) {\n                        if (n.key === name) {\n                            return {\n                                ...n,\n                                field,\n                            };\n                        }\n                    }\n                    return undefined;\n                }\n            };\n            return bptReadNode(offset2 + 32);\n        });\n        return filterUndef(await Promise.all(locs));\n    }\n    /*\n     * retrieve the features from the bigbed data that were found through the\n     * lookup of the extraIndex note that there can be multiple extraIndex, see\n     * the BigBed specification and the -extraIndex argument to bedToBigBed\n     *\n     * @param name - the name to search for\n     *\n     * @param opts - options object with optional AboutSignal\n     *\n     * @return array of Feature\n     */\n    async searchExtraIndex(name, opts = {}) {\n        const blocks = await this.searchExtraIndexBlocks(name, opts);\n        if (blocks.length === 0) {\n            return [];\n        }\n        const view = await this.getUnzoomedView(opts);\n        const res = blocks.map(block => {\n            return new Observable(observer => {\n                view.readFeatures(observer, [block], opts).catch((e) => {\n                    observer.error(e);\n                });\n            }).pipe(reduce((acc, curr) => acc.concat(curr)), map(x => {\n                for (const element of x) {\n                    element.field = block.field;\n                }\n                return x;\n            }));\n        });\n        const ret = await firstValueFrom(merge(...res));\n        return ret.filter(f => f.rest?.split('\\t')[(f.field || 0) - 3] === name);\n    }\n}\n//# sourceMappingURL=bigbed.js.map","import { BigBed } from '@gmod/bbi';\nimport BED from '@gmod/bed';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, doesIntersect2, max, min, updateStatus, } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { firstValueFrom, toArray } from 'rxjs';\nimport { featureData2 } from '../util';\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n    async configurePre(opts) {\n        const pm = this.pluginManager;\n        const bigbed = new BigBed({\n            filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n        });\n        const header = await bigbed.getHeader(opts);\n        const parser = new BED({\n            autoSql: header.autoSql,\n        });\n        return {\n            bigbed,\n            header,\n            parser,\n        };\n    }\n    async configure(opts) {\n        if (!this.cachedP) {\n            this.cachedP = this.configurePre(opts).catch((e) => {\n                this.cachedP = undefined;\n                throw e;\n            });\n        }\n        return this.cachedP;\n    }\n    async getRefNames(opts) {\n        const { header } = await this.configure(opts);\n        return Object.keys(header.refsByName);\n    }\n    async getRefNameAliases(opts) {\n        const { header } = await this.configure(opts);\n        const ret = await Promise.all(Object.keys(header.refsByName).map(async (refName) => (await firstValueFrom(this.getFeatures({\n            assemblyName: '',\n            refName,\n            start: 0,\n            end: 1,\n        }).pipe(toArray())))[0]));\n        return ret\n            .map(r => r.toJSON())\n            .map(r => ({\n            refName: r.ucsc,\n            aliases: [r.ncbi, r.refseq, r.genbank],\n            override: true,\n        }));\n    }\n    async getData() {\n        const refNames = await this.getRefNames();\n        const features = [];\n        for (const refName of refNames) {\n            const f = await firstValueFrom(this.getFeatures({\n                assemblyName: 'unknown',\n                refName,\n                start: 0,\n                end: Number.MAX_SAFE_INTEGER,\n            }).pipe(toArray()));\n            features.push(f);\n        }\n        return features.flat();\n    }\n    async getHeader(opts) {\n        const { parser, header } = await this.configure(opts);\n        const { version, fileType } = header;\n        const { fields, ...autoSql } = parser.autoSql;\n        return {\n            version,\n            fileType,\n            autoSql,\n            fields: await this.getMetadata(opts),\n        };\n    }\n    async getMetadata(opts) {\n        const { parser } = await this.configure(opts);\n        const { fields } = parser.autoSql;\n        return Object.fromEntries(fields.map(({ name, comment }) => [name, comment]));\n    }\n    async getFeaturesHelper({ query, opts, observer, allowRedispatch, originalQuery = query, }) {\n        const { statusCallback = () => { } } = opts;\n        const scoreColumn = this.getConf('scoreColumn');\n        const aggregateField = this.getConf('aggregateField');\n        const { parser, bigbed } = await updateStatus('Downloading header', statusCallback, () => this.configure(opts));\n        const feats = await updateStatus('Downloading features', statusCallback, () => bigbed.getFeatures(query.refName, query.start, query.end, {\n            basesPerSpan: query.end - query.start,\n        }));\n        await updateStatus('Processing features', statusCallback, async () => {\n            var _a;\n            const parentAggregation = {};\n            const parentAggregationFlat = [];\n            if (feats.some(f => f.uniqueId === undefined)) {\n                throw new Error('found uniqueId undefined');\n            }\n            for (const feat of feats) {\n                const splitLine = [\n                    query.refName,\n                    `${feat.start}`,\n                    `${feat.end}`,\n                    ...(((_a = feat.rest) === null || _a === void 0 ? void 0 : _a.split('\\t')) || []),\n                ];\n                const data = parser.parseLine(splitLine, {\n                    uniqueId: feat.uniqueId,\n                });\n                const aggr = data[aggregateField];\n                const aggrIsNotNone = aggr && aggr !== 'none';\n                if (aggrIsNotNone && !parentAggregation[aggr]) {\n                    parentAggregation[aggr] = [];\n                }\n                const { uniqueId, type, chrom, chromStart, chromEnd, description, chromStarts: chromStarts2, blockStarts: blockStarts2, blockSizes: blockSizes2, score: score2, blockCount, thickStart, thickEnd, strand, ...rest } = data;\n                const f = featureData2({\n                    ...rest,\n                    scoreColumn,\n                    splitLine,\n                    parser,\n                    uniqueId,\n                    start: feat.start,\n                    end: feat.end,\n                    refName: query.refName,\n                });\n                if (aggrIsNotNone) {\n                    parentAggregation[aggr].push(f);\n                    parentAggregationFlat.push(f);\n                }\n                else {\n                    if (doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)) {\n                        observer.next(new SimpleFeature({\n                            id: `${this.id}-${uniqueId}`,\n                            data: f,\n                        }));\n                    }\n                }\n            }\n            if (allowRedispatch && parentAggregationFlat.length) {\n                let minStart = Number.POSITIVE_INFINITY;\n                let maxEnd = Number.NEGATIVE_INFINITY;\n                for (const feat of parentAggregationFlat) {\n                    if (feat.start < minStart) {\n                        minStart = feat.start;\n                    }\n                    if (feat.end > maxEnd) {\n                        maxEnd = feat.end;\n                    }\n                }\n                if (maxEnd > query.end || minStart < query.start) {\n                    await this.getFeaturesHelper({\n                        query: {\n                            ...query,\n                            start: minStart - 500000,\n                            end: maxEnd + 500000,\n                        },\n                        opts,\n                        observer,\n                        allowRedispatch: false,\n                        originalQuery: query,\n                    });\n                    return;\n                }\n            }\n            Object.entries(parentAggregation).map(([name, subfeatures]) => {\n                var _a, _b, _c;\n                const s = min(subfeatures.map(f => f.start));\n                const e = max(subfeatures.map(f => f.end));\n                if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n                    const subs = subfeatures.sort((a, b) => a.uniqueId.localeCompare(b.uniqueId));\n                    if (subs.some((a, i) => subs.some((b, j) => i !== j && doesIntersect2(a.start, a.end, b.start, b.end)))) {\n                        observer.next(new SimpleFeature({\n                            id: `${this.id}-${(_a = subs[0]) === null || _a === void 0 ? void 0 : _a.uniqueId}-parent`,\n                            data: {\n                                type: 'gene',\n                                subfeatures: subs,\n                                strand: ((_b = subs[0]) === null || _b === void 0 ? void 0 : _b.strand) || 1,\n                                name,\n                                start: s,\n                                end: e,\n                                refName: query.refName,\n                            },\n                        }));\n                    }\n                    else {\n                        for (const sub of subs) {\n                            observer.next(new SimpleFeature({\n                                id: `${this.id}-${sub.uniqueId}-parent`,\n                                data: {\n                                    type: 'gene',\n                                    subfeatures: [sub],\n                                    strand: ((_c = subs[0]) === null || _c === void 0 ? void 0 : _c.strand) || 1,\n                                    name,\n                                    start: sub.start,\n                                    end: sub.end,\n                                    refName: query.refName,\n                                },\n                            }));\n                        }\n                    }\n                }\n            });\n        });\n        observer.complete();\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            try {\n                await this.getFeaturesHelper({\n                    query: {\n                        ...query,\n                        start: query.start,\n                        end: query.end,\n                    },\n                    opts,\n                    observer,\n                    allowRedispatch: true,\n                });\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n}\n"],"names":["filterUndef","ts","t","BigBed","BBI","AbortablePromiseCache","QuickLRU","args","signal","opts","rest","_scale","extHeaderOffset","b","dataView","offset","count","dataOffset","blocklen","len","buffer","indices","i","type","fieldcount","field","name","decoder","locs","index","offset2","blockSize","keySize","valSize","bptReadNode","nodeOffset","val","nodeType","cnt","keys","leafkeys","key","lastOffset","length","reserved","n","blocks","view","res","block","Observable","observer","e","reduce","acc","curr","map","x","element","firstValueFrom","merge","BigBedAdapter","BaseFeatureDataAdapter","pm","bigbed","openLocation","header","parser","BED","refName","toArray","r","refNames","features","f","version","fileType","fields","autoSql","comment","query","allowRedispatch","originalQuery","statusCallback","scoreColumn","aggregateField","updateStatus","feats","_a","parentAggregation","parentAggregationFlat","feat","splitLine","data","aggr","aggrIsNotNone","uniqueId","chrom","chromStart","chromEnd","description","chromStarts2","blockStarts2","blockSizes2","score2","blockCount","thickStart","thickEnd","strand","featureData2","doesIntersect2","SimpleFeature","minStart","maxEnd","subfeatures","_b","_c","s","min","max","subs","a","j","sub","ObservableCreate"],"mappings":"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","x_google_ignoreList":[0,1]}