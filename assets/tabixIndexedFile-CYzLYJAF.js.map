{"version":3,"file":"tabixIndexedFile-CYzLYJAF.js","sources":["../../node_modules/@gmod/tabix/esm/chunk.js","../../node_modules/@gmod/tabix/esm/indexFile.js","../../node_modules/@gmod/tabix/esm/long.js","../../node_modules/@gmod/tabix/esm/util.js","../../node_modules/@gmod/tabix/esm/virtualOffset.js","../../node_modules/@gmod/tabix/esm/csi.js","../../node_modules/@gmod/tabix/esm/tbi.js","../../node_modules/@gmod/tabix/esm/tabixIndexedFile.js"],"sourcesContent":["// little class representing a chunk in the index\nexport default class Chunk {\n    constructor(minv, maxv, bin, fetchedSize = undefined) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\n//# sourceMappingURL=chunk.js.map","export default class IndexFile {\n    constructor({ filehandle, renameRefSeqs = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeqs;\n    }\n    async getMetadata(opts = {}) {\n        const { indices: _indices, ...rest } = await this.parse(opts);\n        return rest;\n    }\n    _findFirstData(currentFdl, virtualOffset) {\n        if (currentFdl) {\n            return currentFdl.compareTo(virtualOffset) > 0\n                ? virtualOffset\n                : currentFdl;\n        }\n        else {\n            return virtualOffset;\n        }\n    }\n    async parse(opts = {}) {\n        if (!this.parseP) {\n            this.parseP = this._parse(opts).catch((e) => {\n                this.parseP = undefined;\n                throw e;\n            });\n        }\n        return this.parseP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        const idx = await this.parse(opts);\n        return !!idx.indices[seqId]?.binIndex;\n    }\n}\n//# sourceMappingURL=indexFile.js.map","export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","class AbortError extends Error {\n}\n/**\n * Properly check if the given AbortSignal is aborted. Per the standard, if the\n * signal reads as aborted, this function throws either a DOMException\n * AbortError, or a regular error with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted`\n * attribute\n *\n * @returns nothing\n */\nexport function checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        if (typeof DOMException !== 'undefined') {\n            throw new DOMException('aborted', 'AbortError');\n        }\n        else {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n    }\n}\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexport function canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexport function optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk = null;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort(function (c0, c1) {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        return dif !== 0 ? dif : c0.minv.dataPosition - c1.minv.dataPosition;\n    });\n    chunks.forEach(chunk => {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === null) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    });\n    return mergedChunks;\n}\n//# sourceMappingURL=util.js.map","export default class VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n}\nexport function fromBytes(bytes, offset = 0) {\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\n//# sourceMappingURL=virtualOffset.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport Chunk from \"./chunk.js\";\nimport IndexFile from \"./indexFile.js\";\nimport { longFromBytesToUnsigned } from \"./long.js\";\nimport { optimizeChunks } from \"./util.js\";\nimport VirtualOffset, { fromBytes } from \"./virtualOffset.js\";\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nconst formats = {\n    0: 'generic',\n    1: 'SAM',\n    2: 'VCF',\n};\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nexport default class CSI extends IndexFile {\n    constructor(args) {\n        super(args);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return -1;\n        }\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    indexCov() {\n        throw new Error('CSI indexes do not support indexcov');\n    }\n    parseAuxData(bytes, offset) {\n        const dataView = new DataView(bytes.buffer);\n        const formatFlags = dataView.getInt32(offset, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = formats[(formatFlags & 0xf)];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(offset + 4, true),\n            start: dataView.getInt32(offset + 8, true),\n            end: dataView.getInt32(offset + 12, true),\n        };\n        const metaValue = dataView.getInt32(offset + 16, true);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;\n        const skipLines = dataView.getInt32(offset + 20, true);\n        const nameSectionLength = dataView.getInt32(offset + 24, true);\n        const { refIdToName, refNameToId } = this._parseNameBytes(bytes.subarray(offset + 28, offset + 28 + nameSectionLength));\n        return {\n            refIdToName,\n            refNameToId,\n            skipLines,\n            metaChar,\n            columnNumbers,\n            format,\n            coordinateType,\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return {\n            refNameToId,\n            refIdToName,\n        };\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const bytes = await unzip(await this.filehandle.readFile(opts));\n        const dataView = new DataView(bytes.buffer);\n        // check TBI magic numbers\n        let csiVersion;\n        if (dataView.getUint32(0, true) === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (dataView.getUint32(0, true) === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error('Not a CSI file');\n        }\n        this.minShift = dataView.getInt32(4, true);\n        this.depth = dataView.getInt32(8, true);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (this.minShift + this.depth * 3);\n        const auxLength = dataView.getInt32(12, true);\n        const aux = auxLength && auxLength >= 30\n            ? this.parseAuxData(bytes, 16)\n            : {\n                refIdToName: [],\n                refNameToId: {},\n                metaChar: null,\n                columnNumbers: { ref: 0, start: 1, end: 2 },\n                coordinateType: 'zero-based-half-open',\n                format: 'generic',\n            };\n        const refCount = dataView.getInt32(16 + auxLength, true);\n        // read the indexes for each reference sequence\n        let firstDataLine;\n        let currOffset = 16 + auxLength + 4;\n        const indices = new Array(refCount).fill(0).map(() => {\n            const binCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(currOffset, true);\n                if (bin > this.maxBinNumber) {\n                    // this is a fake bin that actually has stats information about the\n                    // reference sequence in it\n                    stats = this.parsePseudoBin(bytes, currOffset + 4);\n                    currOffset += 4 + 8 + 4 + 16 + 16;\n                }\n                else {\n                    const loffset = fromBytes(bytes, currOffset + 4);\n                    firstDataLine = this._findFirstData(firstDataLine, loffset);\n                    const chunkCount = dataView.getInt32(currOffset + 12, true);\n                    currOffset += 16;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, currOffset);\n                        const v = fromBytes(bytes, currOffset + 8);\n                        currOffset += 16;\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            return { binIndex, stats };\n        });\n        return {\n            ...aux,\n            csi: true,\n            refCount,\n            maxBlockSize: 1 << 16,\n            firstDataLine,\n            csiVersion,\n            indices,\n            depth: this.depth,\n            maxBinNumber: this.maxBinNumber,\n            maxRefLength,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        return {\n            lineCount: longFromBytesToUnsigned(bytes, offset + 28),\n        };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        // List of bin #s that overlap min, max\n        const overlappingBins = this.reg2bins(min, max);\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    for (const c of ba.binIndex[bin]) {\n                        chunks.push(new Chunk(c.minv, c.maxv, bin));\n                    }\n                }\n            }\n        }\n        return optimizeChunks(chunks, new VirtualOffset(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n}\n//# sourceMappingURL=csi.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport Chunk from \"./chunk.js\";\nimport IndexFile from \"./indexFile.js\";\nimport { longFromBytesToUnsigned } from \"./long.js\";\nimport { checkAbortSignal, optimizeChunks } from \"./util.js\";\nimport VirtualOffset, { fromBytes } from \"./virtualOffset.js\";\nconst TBI_MAGIC = 21578324; // TBI\\1\nconst TAD_LIDX_SHIFT = 14;\n/**\n * calculate the list of bins that may overlap with region [beg,end)\n * (zero-based half-open)\n */\nfunction reg2bins(beg, end) {\n    beg += 1; // < convert to 1-based closed\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nexport default class TabixIndex extends IndexFile {\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return -1;\n        }\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        return indexData.indices[refId].stats?.lineCount ?? -1;\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const buf = await this.filehandle.readFile(opts);\n        const bytes = await unzip(buf);\n        checkAbortSignal(opts.signal);\n        const dataView = new DataView(bytes.buffer);\n        const magic = dataView.getUint32(0, true);\n        if (magic !== TBI_MAGIC /* \"TBI\\1\" */) {\n            throw new Error('Not a TBI file');\n        }\n        // number of reference sequences in the index\n        const refCount = dataView.getUint32(4, true);\n        const formatFlags = dataView.getUint32(8, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const formatOpts = {\n            0: 'generic',\n            1: 'SAM',\n            2: 'VCF',\n        };\n        const format = formatOpts[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(12, true),\n            start: dataView.getInt32(16, true),\n            end: dataView.getInt32(20, true),\n        };\n        const metaValue = dataView.getInt32(24, true);\n        const depth = 5;\n        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (14 + depth * 3);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;\n        const skipLines = dataView.getInt32(28, true);\n        // read sequence dictionary\n        const nameSectionLength = dataView.getInt32(32, true);\n        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));\n        // read the indexes for each reference sequence\n        let currOffset = 36 + nameSectionLength;\n        let firstDataLine;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(currOffset, true);\n                currOffset += 4;\n                if (bin > maxBinNumber + 1) {\n                    throw new Error('tabix index contains too many bins, please use a CSI index');\n                }\n                else if (bin === maxBinNumber + 1) {\n                    const chunkCount = dataView.getInt32(currOffset, true);\n                    currOffset += 4;\n                    if (chunkCount === 2) {\n                        stats = this.parsePseudoBin(bytes, currOffset);\n                    }\n                    currOffset += 16 * chunkCount;\n                }\n                else {\n                    const chunkCount = dataView.getInt32(currOffset, true);\n                    currOffset += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, currOffset);\n                        const v = fromBytes(bytes, currOffset + 8);\n                        currOffset += 16;\n                        firstDataLine = this._findFirstData(firstDataLine, u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            // the linear index\n            const linearCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const linearIndex = new Array(linearCount);\n            for (let k = 0; k < linearCount; k += 1) {\n                linearIndex[k] = fromBytes(bytes, currOffset);\n                currOffset += 8;\n                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);\n            }\n            return {\n                binIndex,\n                linearIndex,\n                stats,\n            };\n        });\n        return {\n            indices,\n            metaChar,\n            maxBinNumber,\n            maxRefLength,\n            skipLines,\n            firstDataLine,\n            columnNumbers,\n            coordinateType,\n            format,\n            refIdToName,\n            refNameToId,\n            maxBlockSize: 1 << 16,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        return {\n            lineCount: longFromBytesToUnsigned(bytes, offset + 16),\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return {\n            refNameToId,\n            refIdToName,\n        };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        const minOffset = ba.linearIndex.length\n            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length\n                ? ba.linearIndex.length - 1\n                : min >> TAD_LIDX_SHIFT]\n            : new VirtualOffset(0, 0);\n        if (!minOffset) {\n            console.warn('querying outside of possible tabix range');\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    for (const c of ba.binIndex[bin]) {\n                        chunks.push(new Chunk(c.minv, c.maxv, bin));\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest = null;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp) {\n                if (!lowest || vp.compareTo(lowest) < 0) {\n                    lowest = vp;\n                }\n            }\n        }\n        return optimizeChunks(chunks, lowest);\n    }\n}\n//# sourceMappingURL=tbi.js.map","import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle';\nimport { LocalFile, RemoteFile } from 'generic-filehandle2';\nimport LRU from 'quick-lru';\nimport CSI from \"./csi.js\";\nimport TBI from \"./tbi.js\";\nimport { checkAbortSignal } from \"./util.js\";\nfunction isASCII(str) {\n    // eslint-disable-next-line no-control-regex\n    return /^[\\u0000-\\u007F]*$/.test(str);\n}\nexport default class TabixIndexedFile {\n    /**\n     * @param {object} args\n     *\n     * @param {string} [args.path]\n     *\n     * @param {filehandle} [args.filehandle]\n     *\n     * @param {string} [args.tbiPath]\n     *\n     * @param {filehandle} [args.tbiFilehandle]\n     *\n     * @param {string} [args.csiPath]\n     *\n     * @param {filehandle} [args.csiFilehandle]\n     *\n     * @param {url} [args.url]\n     *\n     * @param {csiUrl} [args.csiUrl]\n     *\n     * @param {tbiUrl} [args.tbiUrl]\n     *\n     * @param {function} [args.renameRefSeqs] optional function with sig `string\n     * => string` to transform reference sequence names for the purpose of\n     * indexing and querying. note that the data that is returned is not altered,\n     * just the names of the reference sequences that are used for querying.\n     */\n    constructor({ path, filehandle, url, tbiPath, tbiUrl, tbiFilehandle, csiPath, csiUrl, csiFilehandle, renameRefSeqs = n => n, chunkCacheSize = 5 * 2 ** 20, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else if (url) {\n            this.filehandle = new RemoteFile(url);\n        }\n        else {\n            throw new TypeError('must provide either filehandle or path');\n        }\n        if (tbiFilehandle) {\n            this.index = new TBI({\n                filehandle: tbiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (csiFilehandle) {\n            this.index = new CSI({\n                filehandle: csiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (tbiPath) {\n            this.index = new TBI({\n                filehandle: new LocalFile(tbiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (csiPath) {\n            this.index = new CSI({\n                filehandle: new LocalFile(csiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (path) {\n            this.index = new TBI({\n                filehandle: new LocalFile(`${path}.tbi`),\n                renameRefSeqs,\n            });\n        }\n        else if (csiUrl) {\n            this.index = new CSI({\n                filehandle: new RemoteFile(csiUrl),\n            });\n        }\n        else if (tbiUrl) {\n            this.index = new TBI({\n                filehandle: new RemoteFile(tbiUrl),\n            });\n        }\n        else if (url) {\n            this.index = new TBI({\n                filehandle: new RemoteFile(`${url}.tbi`),\n            });\n        }\n        else {\n            throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl');\n        }\n        this.renameRefSeq = renameRefSeqs;\n        this.chunkCache = new AbortablePromiseCache({\n            cache: new LRU({ maxSize: Math.floor(chunkCacheSize / (1 << 16)) }),\n            fill: (args, signal) => this.readChunk(args, { signal }),\n        });\n    }\n    /**\n     * @param refName name of the reference sequence\n     *\n     * @param start start of the region (in 0-based half-open coordinates)\n     *\n     * @param end end of the region (in 0-based half-open coordinates)\n     *\n     * @param opts callback called for each line in the region. can also pass a\n     * object param containing obj.lineCallback, obj.signal, etc\n     *\n     * @returns promise that is resolved when the whole read is finished,\n     * rejected on error\n     */\n    async getLines(refName, s, e, opts) {\n        let signal;\n        let options = {};\n        let callback;\n        if (typeof opts === 'function') {\n            callback = opts;\n        }\n        else {\n            options = opts;\n            callback = opts.lineCallback;\n            signal = opts.signal;\n        }\n        const metadata = await this.index.getMetadata(options);\n        checkAbortSignal(signal);\n        const start = s ?? 0;\n        const end = e ?? metadata.maxRefLength;\n        if (!(start <= end)) {\n            throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');\n        }\n        if (start === end) {\n            return;\n        }\n        const chunks = await this.index.blocksForRange(refName, start, end, options);\n        checkAbortSignal(signal);\n        const decoder = new TextDecoder('utf8');\n        // now go through each chunk and parse and filter the lines out of it\n        for (const c of chunks) {\n            const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c, signal);\n            checkAbortSignal(signal);\n            let blockStart = 0;\n            let pos = 0;\n            // fast path, Buffer is just ASCII chars and not gigantor, can be\n            // converted to string and processed directly. if it is not ASCII or\n            // gigantic (chrome max str len is 512Mb), we have to decode line by line\n            const str = decoder.decode(buffer);\n            const strIsASCII = isASCII(str);\n            while (blockStart < str.length) {\n                let line;\n                let n;\n                if (strIsASCII) {\n                    n = str.indexOf('\\n', blockStart);\n                    if (n === -1) {\n                        break;\n                    }\n                    line = str.slice(blockStart, n);\n                }\n                else {\n                    n = buffer.indexOf('\\n'.charCodeAt(0), blockStart);\n                    if (n === -1) {\n                        break;\n                    }\n                    const b = buffer.slice(blockStart, n);\n                    line = decoder.decode(b);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (dpositions) {\n                    while (blockStart + c.minv.dataPosition >= dpositions[pos++]) { }\n                    pos--;\n                }\n                // filter the line for whether it is within the requested range\n                const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);\n                if (overlaps) {\n                    callback(line, \n                    // cpositions[pos] refers to actual file offset of a bgzip block\n                    // boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a\n                    // \"unique\" address space so that data in that block could never\n                    // overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset\n                    // from that bgzip block boundary, and since the cpositions are\n                    // multiplied by (1 << 8) these uncompressed offsets get a unique\n                    // space\n                    cpositions[pos] * (1 << 8) +\n                        (blockStart - dpositions[pos]) +\n                        c.minv.dataPosition +\n                        1);\n                }\n                else if (startCoordinate !== undefined && startCoordinate >= end) {\n                    // the lines were overlapping the region, but now have stopped, so we\n                    // must be at the end of the relevant data and we can stop processing\n                    // data now\n                    return;\n                }\n                blockStart = n + 1;\n            }\n        }\n    }\n    async getMetadata(opts = {}) {\n        return this.index.getMetadata(opts);\n    }\n    /**\n     * get a buffer containing the \"header\" region of the file, which are the\n     * bytes up to the first non-meta line\n     */\n    async getHeaderBuffer(opts = {}) {\n        const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);\n        checkAbortSignal(opts.signal);\n        const maxFetch = (firstDataLine?.blockPosition || 0) + maxBlockSize;\n        // TODO: what if we don't have a firstDataLine, and the header actually\n        // takes up more than one block? this case is not covered here\n        const buf = await this.filehandle.read(maxFetch, 0, opts);\n        const bytes = await unzip(buf);\n        // trim off lines after the last non-meta line\n        if (metaChar) {\n            // trim backward from the end\n            let lastNewline = -1;\n            const newlineByte = '\\n'.charCodeAt(0);\n            const metaByte = metaChar.charCodeAt(0);\n            for (let i = 0; i < bytes.length; i += 1) {\n                if (i === lastNewline + 1 && bytes[i] !== metaByte) {\n                    break;\n                }\n                if (bytes[i] === newlineByte) {\n                    lastNewline = i;\n                }\n            }\n            return bytes.subarray(0, lastNewline + 1);\n        }\n        return bytes;\n    }\n    /**\n     * get a string containing the \"header\" region of the file, is the portion up\n     * to the first non-meta line\n     *\n     * @returns {Promise} for a string\n     */\n    async getHeader(opts = {}) {\n        const decoder = new TextDecoder('utf8');\n        const bytes = await this.getHeaderBuffer(opts);\n        return decoder.decode(bytes);\n    }\n    /**\n     * get an array of reference sequence names, in the order in which they occur\n     * in the file. reference sequence renaming is not applied to these names.\n     */\n    async getReferenceSequenceNames(opts = {}) {\n        const metadata = await this.getMetadata(opts);\n        return metadata.refIdToName;\n    }\n    /**\n     * @param {object} metadata metadata object from the parsed index, containing\n     * columnNumbers, metaChar, and format\n     *\n     * @param {string} regionRefName\n     *\n     * @param {number} regionStart region start coordinate (0-based-half-open)\n     *\n     * @param {number} regionEnd region end coordinate (0-based-half-open)\n     *\n     * @param {array[string]} line\n     *\n     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,\n     * true if line is a data line that overlaps the given region\n     */\n    checkLine(metadata, regionRefName, regionStart, regionEnd, line) {\n        const { columnNumbers, metaChar, coordinateType, format } = metadata;\n        // skip meta lines\n        if (metaChar && line.startsWith(metaChar)) {\n            return { overlaps: false };\n        }\n        // check ref/start/end using column metadata from index\n        let { ref, start, end } = columnNumbers;\n        if (!ref) {\n            ref = 0;\n        }\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = 0;\n        }\n        if (format === 'VCF') {\n            end = 8;\n        }\n        const maxColumn = Math.max(ref, start, end);\n        // this code is kind of complex, but it is fairly fast. basically, we want\n        // to avoid doing a split, because if the lines are really long that could\n        // lead to us allocating a bunch of extra memory, which is slow\n        let currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata\n        let currentColumnStart = 0;\n        let refSeq = '';\n        let startCoordinate = -Infinity;\n        const l = line.length;\n        for (let i = 0; i < l + 1; i++) {\n            if (line[i] === '\\t' || i === l) {\n                if (currentColumnNumber === ref) {\n                    if (this.renameRefSeq(line.slice(currentColumnStart, i)) !==\n                        regionRefName) {\n                        return {\n                            overlaps: false,\n                        };\n                    }\n                }\n                else if (currentColumnNumber === start) {\n                    startCoordinate = parseInt(line.slice(currentColumnStart, i), 10);\n                    // we convert to 0-based-half-open\n                    if (coordinateType === '1-based-closed') {\n                        startCoordinate -= 1;\n                    }\n                    if (startCoordinate >= regionEnd) {\n                        return {\n                            startCoordinate,\n                            overlaps: false,\n                        };\n                    }\n                    if (end === 0 || end === start) {\n                        // if we have no end, we assume the feature is 1 bp long\n                        if (startCoordinate + 1 <= regionStart) {\n                            return {\n                                startCoordinate,\n                                overlaps: false,\n                            };\n                        }\n                    }\n                }\n                else if (format === 'VCF' && currentColumnNumber === 4) {\n                    refSeq = line.slice(currentColumnStart, i);\n                }\n                else if (currentColumnNumber === end) {\n                    // this will never match if there is no end column\n                    const endCoordinate = format === 'VCF'\n                        ? this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i))\n                        : Number.parseInt(line.slice(currentColumnStart, i), 10);\n                    if (endCoordinate <= regionStart) {\n                        return {\n                            overlaps: false,\n                        };\n                    }\n                }\n                currentColumnStart = i + 1;\n                currentColumnNumber += 1;\n                if (currentColumnNumber > maxColumn) {\n                    break;\n                }\n            }\n        }\n        return {\n            startCoordinate,\n            overlaps: true,\n        };\n    }\n    _getVcfEnd(startCoordinate, refSeq, info) {\n        let endCoordinate = startCoordinate + refSeq.length;\n        // ignore TRA features as they specify CHR2 and END as being on a different\n        // chromosome\n        //\n        // if CHR2 is on the same chromosome, still ignore it because there should\n        // be another pairwise feature at the end of this one\n        const isTRA = info.includes('SVTYPE=TRA');\n        if (info[0] !== '.' && !isTRA) {\n            let prevChar = ';';\n            for (let j = 0; j < info.length; j += 1) {\n                if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {\n                    let valueEnd = info.indexOf(';', j);\n                    if (valueEnd === -1) {\n                        valueEnd = info.length;\n                    }\n                    endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10);\n                    break;\n                }\n                prevChar = info[j];\n            }\n        }\n        else if (isTRA) {\n            return startCoordinate + 1;\n        }\n        return endCoordinate;\n    }\n    /**\n     * return the approximate number of data lines in the given reference\n     * sequence\n     *\n     * @param refSeq reference sequence name\n     *\n     * @returns number of data lines present on that reference sequence\n     */\n    async lineCount(refName, opts = {}) {\n        return this.index.lineCount(refName, opts);\n    }\n    /**\n     * read and uncompress the data in a chunk (composed of one or more\n     * contiguous bgzip blocks) of the file\n     */\n    async readChunk(c, opts = {}) {\n        const ret = await this.filehandle.read(c.fetchedSize(), c.minv.blockPosition, opts);\n        return unzipChunkSlice(ret, c);\n    }\n}\n//# sourceMappingURL=tabixIndexedFile.js.map"],"names":["Chunk","minv","maxv","bin","fetchedSize","b","IndexFile","filehandle","renameRefSeqs","opts","_indices","rest","currentFdl","virtualOffset","e","seqId","_a","TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","AbortError","checkAbortSignal","signal","canMergeBlocks","chunk1","chunk2","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","c0","c1","dif","chunk","VirtualOffset","blockPosition","dataPosition","fromBytes","bytes","offset","CSI1_MAGIC","CSI2_MAGIC","formats","lshift","num","bits","rshift","CSI","args","refName","indexData","refId","stats","dataView","formatFlags","coordinateType","format","columnNumbers","metaValue","metaChar","skipLines","nameSectionLength","refIdToName","refNameToId","namesBytes","currRefId","currNameStart","decoder","unzip","csiVersion","maxRefLength","auxLength","aux","refCount","firstDataLine","currOffset","indices","binCount","binIndex","j","loffset","chunkCount","k","u","v","min","max","ba","overlappingBins","start","end","c","beg","l","t","s","bins","TBI_MAGIC","TAD_LIDX_SHIFT","reg2bins","TabixIndex","buf","depth","maxBinNumber","linearCount","linearIndex","nintv","minLin","maxLin","vp","isASCII","str","TabixIndexedFile","path","url","tbiPath","tbiUrl","tbiFilehandle","csiPath","csiUrl","csiFilehandle","n","chunkCacheSize","LocalFile","RemoteFile","TBI","AbortablePromiseCache","LRU","options","callback","metadata","buffer","cpositions","dpositions","blockStart","pos","strIsASCII","line","startCoordinate","overlaps","maxBlockSize","maxFetch","lastNewline","newlineByte","metaByte","regionRefName","regionStart","regionEnd","ref","maxColumn","currentColumnNumber","currentColumnStart","refSeq","info","endCoordinate","isTRA","prevChar","valueEnd","ret","unzipChunkSlice"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}