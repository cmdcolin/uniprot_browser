import{p as w}from"./index-BzItsYpE.js";function y(r){let o=0;for(const n of r)o+=n.length;return o}function b(r){const o=new Uint8Array(y(r));let n=0;for(const t of r)o.set(t,n),n+=t.length;return o}const{Z_SYNC_FLUSH:d,Inflate:m}=w;async function x(r){try{let o,n=0,t;const i=[];do{const s=r.subarray(n);if(t=new m,{strm:o}=t,t.push(s,d),t.err)throw new Error(t.msg);n+=o.next_in,i.push(t.result)}while(o.avail_in);return b(i)}catch(o){throw/incorrect header check/.exec(`${o}`)?new Error("problem decompressing block: incorrect gzip header check"):o}}async function _(r,o){try{let n;const{minv:t,maxv:i}=o;let s=t.blockPosition,a=t.dataPosition;const e=[],l=[],h=[];let u=0;do{const k=r.subarray(s-t.blockPosition),c=new m;if({strm:n}=c,c.push(k,d),c.err)throw new Error(c.msg);const p=c.result;e.push(p);let f=p.length;l.push(s),h.push(a),e.length===1&&t.dataPosition&&(e[0]=e[0].subarray(t.dataPosition),f=e[0].length);const g=s;if(s+=n.next_in,a+=f,g>=i.blockPosition){e[u]=e[u].subarray(0,i.blockPosition===t.blockPosition?i.dataPosition-t.dataPosition+1:i.dataPosition+1),l.push(s),h.push(a);break}u++}while(n.avail_in);return{buffer:b(e),cpositions:l,dpositions:h}}catch(n){throw/incorrect header check/.exec(`${n}`)?new Error("problem decompressing block: incorrect gzip header check"):n}}export{_ as a,b as c,x as u};
//# sourceMappingURL=unzip-OY3UkAtn.js.map
