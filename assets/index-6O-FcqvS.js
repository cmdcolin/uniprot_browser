import{cm as M}from"./index-B3kPj2Rj.js";function O(o,r,e){const t=r.split("	"),i={};let n=0;if(o.includes("GT")){const l=o.split(":");if(l.length===1)for(const s of e)i[s]=t[n++];else{const s=l.indexOf("GT");if(s===0)for(const a of e){const p=t[n++],c=p.indexOf(":");i[a]=c!==-1?p.slice(0,c):p}else for(const a of e){const p=t[n++].split(":");i[a]=p[s]}}}return i}function P(o){const r=[];let e="",t=!1,i=!1;for(const n of o)n==='"'?(t=!t,e+=n):n==="["?(i=!0,e+=n):n==="]"?(i=!1,e+=n):n===","&&!t&&!i?(r.push(e.trim()),e=""):e+=n;return e&&r.push(e.trim()),r}function C(o,r){const e=o.indexOf(r);return[o.slice(0,e),o.slice(e+1)]}function L(o){const r=o.replace(/^<|>$/g,"");return Object.fromEntries(P(r).map(e=>{const[t,i]=C(e,"=");return i&&i.startsWith("[")&&i.endsWith("]")?[t,i.slice(1,-1).split(",").map(n=>n.trim())]:i&&i.startsWith('"')&&i.endsWith('"')?[t,i.slice(1,-1)]:[t,i?.replaceAll(/^"|"$/g,"")]}))}const y={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function w(o){try{return decodeURIComponent(o)}catch{return o}}class H{constructor({header:r="",strict:e=!0}){if(!r.length)throw new Error("empty header received");const t=r.split(/[\r\n]+/).filter(Boolean);if(!t.length)throw new Error("no non-empty header lines specified");this.strict=e,this.metadata=JSON.parse(JSON.stringify({INFO:y.InfoFields,FORMAT:y.GenotypeFields,ALT:y.AltTypes,FILTER:y.FilterTypes}));let i;if(t.forEach(a=>{if(a.startsWith("#"))a.startsWith("##")?this.parseMetadata(a):i=a;else throw new Error(`Bad line in header:
${a}`)}),!i)throw new Error("No format line found in header");const n=i.trim().split("	"),l=n.slice(0,8),s=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(n.length<8)throw new Error(`VCF header missing columns:
${i}`);if(l.length!==s.length||!l.every((a,p)=>a===s[p]))throw new Error(`VCF column headers not correct:
${i}`);this.samples=n.slice(9)}parseSamples(r,e){const t={};if(r){const i=e.split("	"),n=r.split(":"),l=n.map(s=>{const a=this.getMetadata("FORMAT",s,"Type");return a==="Integer"||a==="Float"});for(let s=0;s<this.samples.length;s++){const a=this.samples[s];t[a]={};const p=i[s].split(":");for(let c=0;c<p.length;c++){const u=p[c];t[a][n[c]]=u===""||u==="."?void 0:u.split(",").map(m=>m==="."?void 0:l[c]?+m:m)}}}return t}parseMetadata(r){const e=/^##(.+?)=(.*)/.exec(r.trim());if(!e)throw new Error(`Line is not a valid metadata line: ${r}`);const[t,i]=e.slice(1,3),n=t;if(i?.startsWith("<")){n in this.metadata||(this.metadata[n]={});const[l,s]=this.parseStructuredMetaVal(i);l?this.metadata[n][l]=s:this.metadata[n]=s}else this.metadata[n]=i}parseStructuredMetaVal(r){const e=L(r),t=e.ID;return delete e.ID,"Number"in e&&(Number.isNaN(Number(e.Number))||(e.Number=Number(e.Number))),[t,e]}getMetadata(...r){let e=this.metadata;for(const t of r)if(e=e[t],!e)return e;return e}parseLine(r){let e=0;for(let h=0;e<r.length&&(r[e]==="	"&&(h+=1),h!==9);e+=1);const t=r.slice(0,e).split("	"),i=r.slice(e+1),[n,l,s,a,p,c,u]=t,m=n,T=+l,g=s==="."?void 0:s.split(";"),I=a,S=p==="."?void 0:p.split(","),A=c==="."?void 0:+c,f=u==="."?void 0:u.split(";"),E=t[8];if(this.strict&&!t[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const R=t[7]?.includes("%"),F=t[7]===void 0||t[7]==="."?{}:Object.fromEntries(t[7].split(";").map(h=>{const[D,v]=h.split("="),N=v?.split(",").map(d=>d==="."?void 0:d).map(d=>d&&R?w(d):d),b=this.getMetadata("INFO",D,"Type");return b==="Integer"||b==="Float"?[D,N?.map(d=>d===void 0?void 0:Number(d))]:b==="Flag"?[D,!0]:[D,N??!0]}));return{CHROM:m,POS:T,ALT:S,INFO:F,REF:I,FILTER:f&&f.length===1&&f[0]==="PASS"?"PASS":f,ID:g,QUAL:A,FORMAT:E,SAMPLES:()=>this.parseSamples(t[8]??"",i),GENOTYPES:()=>O(t[8]??"",i,this.samples)}}}function G(o,r){const{REF:e="",ALT:t,POS:i,CHROM:n,ID:l}=o,s=i-1,[a,p]=M(e,t,r);return{refName:n,start:s,end:V(o),description:p,type:a,name:l?.join(",")}}function V(o){const{POS:r,REF:e="",ALT:t}=o,i=t?.includes("<TRA>"),n=r-1;if(t?.some(s=>s.includes("<"))){const s=o.INFO;if(s.END&&!i)return+s.END[0]}return n+e.length}class Q{constructor(r){this.variant=r.variant,this.parser=r.parser,this.data=G(this.variant,this.parser),this._id=r.id}get(r){var e;return r==="samples"?this.variant.SAMPLES():r==="genotypes"?this.variant.GENOTYPES():(e=this.data[r])!==null&&e!==void 0?e:this.variant[r]}parent(){}children(){}id(){return this._id}toJSON(){const{SAMPLES:r,GENOTYPES:e,...t}=this.variant;return{uniqueId:this._id,...t,...this.data,samples:this.variant.SAMPLES()}}}export{H as V,Q as a};
//# sourceMappingURL=index-6O-FcqvS.js.map
