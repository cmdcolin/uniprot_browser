{"version":3,"file":"BgzipFastaAdapter-CKQSvGTl.js","sources":["../../node_modules/@gmod/bgzf-filehandle/esm/long.js","../../node_modules/@gmod/bgzf-filehandle/esm/gziIndex.js","../../node_modules/@gmod/bgzf-filehandle/esm/bgzFilehandle.js","../../node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","../../node_modules/@jbrowse/plugin-sequence/esm/BgzipFastaAdapter/BgzipFastaAdapter.js"],"sourcesContent":["export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","import { longFromBytesToUnsigned } from \"./long.js\";\nconst UNCOMPRESSED_POSITION = 1;\n// binary search to find the block that the\n// read starts in and extend forward from that\nfunction compare(position, entry, nextEntry) {\n    const uncompressedPosition = entry[UNCOMPRESSED_POSITION];\n    const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity;\n    if (uncompressedPosition <= position && nextUncompressedPosition > position) {\n        // block overlaps read start\n        return 0;\n    }\n    else if (uncompressedPosition < position) {\n        // block is before read start\n        return -1;\n    }\n    else {\n        // block is after read start\n        return 1;\n    }\n}\nexport default class GziIndex {\n    constructor({ filehandle }) {\n        this.filehandle = filehandle;\n    }\n    _getIndex() {\n        if (!this.index) {\n            this.index = this._readIndex().catch((e) => {\n                this.index = undefined;\n                throw e;\n            });\n        }\n        return this.index;\n    }\n    async _readIndex() {\n        const buf = await this.filehandle.read(8, 0);\n        const numEntries = longFromBytesToUnsigned(buf);\n        if (!numEntries) {\n            return [[0, 0]];\n        }\n        const entries = new Array(numEntries + 1);\n        entries[0] = [0, 0];\n        // TODO rewrite this to make an index-index that stays in memory\n        const bufSize = 8 * 2 * numEntries;\n        if (bufSize > Number.MAX_SAFE_INTEGER) {\n            throw new TypeError('integer overflow');\n        }\n        const b2 = await this.filehandle.read(bufSize, 8);\n        for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n            const compressedPos = longFromBytesToUnsigned(b2, entryNumber * 16);\n            const uncompressedPos = longFromBytesToUnsigned(b2, entryNumber * 16 + 8);\n            entries[entryNumber + 1] = [compressedPos, uncompressedPos];\n        }\n        return entries;\n    }\n    async getLastBlock() {\n        const entries = await this._getIndex();\n        return entries.at(-1);\n    }\n    async getRelevantBlocksForRead(length, position) {\n        const endPosition = position + length;\n        if (length === 0) {\n            return [];\n        }\n        const entries = await this._getIndex();\n        const relevant = [];\n        let lowerBound = 0;\n        let upperBound = entries.length - 1;\n        let searchPosition = Math.floor(entries.length / 2);\n        let comparison = compare(position, entries[searchPosition], entries[searchPosition + 1]);\n        while (comparison !== 0) {\n            if (comparison > 0) {\n                upperBound = searchPosition - 1;\n            }\n            else if (comparison < 0) {\n                lowerBound = searchPosition + 1;\n            }\n            searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound;\n            comparison = compare(position, entries[searchPosition], entries[searchPosition + 1]);\n        }\n        // here's where we read forward\n        relevant.push(entries[searchPosition]);\n        let i = searchPosition + 1;\n        for (; i < entries.length; i += 1) {\n            relevant.push(entries[i]);\n            if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n                break;\n            }\n        }\n        if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n            relevant.push([]);\n        }\n        return relevant;\n    }\n}\n//# sourceMappingURL=gziIndex.js.map","import GziIndex from \"./gziIndex.js\";\nimport { unzip } from \"./unzip.js\";\nimport { concatUint8Array } from \"./util.js\";\nexport default class BgzFilehandle {\n    constructor({ filehandle, gziFilehandle, }) {\n        this.filehandle = filehandle;\n        this.gzi = new GziIndex({\n            filehandle: gziFilehandle,\n        });\n    }\n    async _readAndUncompressBlock(compressedPosition, nextCompressedPosition) {\n        let next = nextCompressedPosition;\n        if (!next) {\n            next = (await this.filehandle.stat()).size;\n        }\n        // read the compressed data into the block buffer\n        const blockCompressedLength = next - compressedPosition;\n        const blockBuffer = await this.filehandle.read(blockCompressedLength, compressedPosition);\n        // uncompress it\n        return unzip(blockBuffer);\n    }\n    async read(length, position) {\n        const blockPositions = await this.gzi.getRelevantBlocksForRead(length, position);\n        const blocks = [];\n        for (let blockNum = 0; blockNum < blockPositions.length - 1; blockNum += 1) {\n            const uncompressedBuffer = await this._readAndUncompressBlock(blockPositions[blockNum][0], blockPositions[blockNum + 1][0]);\n            const [, uncompressedPosition] = blockPositions[blockNum];\n            const sourceOffset = uncompressedPosition >= position ? 0 : position - uncompressedPosition;\n            const sourceEnd = Math.min(position + length, uncompressedPosition + uncompressedBuffer.length) - uncompressedPosition;\n            if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n                blocks.push(uncompressedBuffer.subarray(sourceOffset, sourceEnd));\n            }\n        }\n        return concatUint8Array(blocks);\n    }\n}\n//# sourceMappingURL=bgzFilehandle.js.map","import { BgzfFilehandle } from '@gmod/bgzf-filehandle';\nimport { LocalFile } from 'generic-filehandle2';\nimport IndexedFasta from \"./indexedFasta.js\";\nexport default class BgzipIndexedFasta extends IndexedFasta {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, }) {\n        super({ fasta, path, fai, faiPath });\n        if (fasta && gzi) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            // @ts-expect-error\n            this.fasta = new BgzfFilehandle({\n                filehandle: new LocalFile(path),\n                gziFilehandle: new LocalFile(gziPath),\n            });\n        }\n    }\n}\n//# sourceMappingURL=bgzipIndexedFasta.js.map","import { BgzipIndexedFasta } from '@gmod/indexedfasta';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter';\nexport default class BgzipFastaAdapter extends IndexedFasta {\n    async setupPre() {\n        const fastaLocation = this.getConf('fastaLocation');\n        const faiLocation = this.getConf('faiLocation');\n        const gziLocation = this.getConf('gziLocation');\n        const fastaOpts = {\n            fasta: openLocation(fastaLocation, this.pluginManager),\n            fai: openLocation(faiLocation, this.pluginManager),\n            gzi: openLocation(gziLocation, this.pluginManager),\n        };\n        return { fasta: new BgzipIndexedFasta(fastaOpts) };\n    }\n}\n"],"names":["TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","UNCOMPRESSED_POSITION","compare","position","entry","nextEntry","uncompressedPosition","nextUncompressedPosition","GziIndex","filehandle","buf","numEntries","entries","bufSize","b2","entryNumber","compressedPos","uncompressedPos","length","endPosition","relevant","lowerBound","upperBound","searchPosition","comparison","BgzFilehandle","gziFilehandle","compressedPosition","nextCompressedPosition","next","blockCompressedLength","blockBuffer","unzip","blockPositions","blocks","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","concatUint8Array","BgzipIndexedFasta","IndexedFasta","fasta","path","fai","faiPath","gzi","gziPath","BgzfFilehandle","LocalFile","BgzipFastaAdapter","fastaLocation","faiLocation","gziLocation","fastaOpts","openLocation"],"mappings":"6VAAO,MAAMA,EAAiB,MACjBC,EAAiBD,EAAiBA,EACxC,SAASE,EAAwBC,EAAQC,EAAI,EAAG,CACnD,MAAMC,EAAMF,EAAOC,CAAC,EACfD,EAAOC,EAAI,CAAC,GAAK,EACjBD,EAAOC,EAAI,CAAC,GAAK,GACjBD,EAAOC,EAAI,CAAC,GAAK,GAKtB,QAJaD,EAAOC,EAAI,CAAC,EACpBD,EAAOC,EAAI,CAAC,GAAK,EACjBD,EAAOC,EAAI,CAAC,GAAK,GACjBD,EAAOC,EAAI,CAAC,GAAK,MACL,GAAKH,GAAkBI,IAAQ,EACpD,CCXA,MAAMC,EAAwB,EAG9B,SAASC,EAAQC,EAAUC,EAAOC,EAAW,CACzC,MAAMC,EAAuBF,EAAMH,CAAqB,EAClDM,EAA2BF,EAC3BA,EAAUJ,CAAqB,EAC/B,IACN,OAAIK,GAAwBH,GAAYI,EAA2BJ,EAExD,EAEFG,EAAuBH,EAErB,GAIA,CAEf,CACe,MAAMK,CAAS,CAC1B,YAAY,CAAE,WAAAC,GAAc,CACxB,KAAK,WAAaA,CACtB,CACA,WAAY,CACR,OAAK,KAAK,QACN,KAAK,MAAQ,KAAK,WAAU,EAAG,MAAO,GAAM,CACxC,WAAK,MAAQ,OACP,CACV,CAAC,GAEE,KAAK,KAChB,CACA,MAAM,YAAa,CACf,MAAMC,EAAM,MAAM,KAAK,WAAW,KAAK,EAAG,CAAC,EACrCC,EAAad,EAAwBa,CAAG,EAC9C,GAAI,CAACC,EACD,MAAO,CAAC,CAAC,EAAG,CAAC,CAAC,EAElB,MAAMC,EAAU,IAAI,MAAMD,EAAa,CAAC,EACxCC,EAAQ,CAAC,EAAI,CAAC,EAAG,CAAC,EAElB,MAAMC,EAAU,GAAQF,EACxB,GAAIE,EAAU,OAAO,iBACjB,MAAM,IAAI,UAAU,kBAAkB,EAE1C,MAAMC,EAAK,MAAM,KAAK,WAAW,KAAKD,EAAS,CAAC,EAChD,QAASE,EAAc,EAAGA,EAAcJ,EAAYI,GAAe,EAAG,CAClE,MAAMC,EAAgBnB,EAAwBiB,EAAIC,EAAc,EAAE,EAC5DE,EAAkBpB,EAAwBiB,EAAIC,EAAc,GAAK,CAAC,EACxEH,EAAQG,EAAc,CAAC,EAAI,CAACC,EAAeC,CAAe,CAC9D,CACA,OAAOL,CACX,CACA,MAAM,cAAe,CAEjB,OADgB,MAAM,KAAK,UAAS,GACrB,GAAG,EAAE,CACxB,CACA,MAAM,yBAAyBM,EAAQf,EAAU,CAC7C,MAAMgB,EAAchB,EAAWe,EAC/B,GAAIA,IAAW,EACX,MAAO,CAAA,EAEX,MAAMN,EAAU,MAAM,KAAK,UAAS,EAC9BQ,EAAW,CAAA,EACjB,IAAIC,EAAa,EACbC,EAAaV,EAAQ,OAAS,EAC9BW,EAAiB,KAAK,MAAMX,EAAQ,OAAS,CAAC,EAC9CY,EAAatB,EAAQC,EAAUS,EAAQW,CAAc,EAAGX,EAAQW,EAAiB,CAAC,CAAC,EACvF,KAAOC,IAAe,GACdA,EAAa,EACbF,EAAaC,EAAiB,EAEzBC,EAAa,IAClBH,EAAaE,EAAiB,GAElCA,EAAiB,KAAK,MAAMD,EAAaD,GAAc,CAAC,EAAIA,EAC5DG,EAAatB,EAAQC,EAAUS,EAAQW,CAAc,EAAGX,EAAQW,EAAiB,CAAC,CAAC,EAGvFH,EAAS,KAAKR,EAAQW,CAAc,CAAC,EACrC,IAAIxB,EAAIwB,EAAiB,EACzB,KAAOxB,EAAIa,EAAQ,SACfQ,EAAS,KAAKR,EAAQb,CAAC,CAAC,EACpB,EAAAa,EAAQb,CAAC,EAAEE,CAAqB,GAAKkB,IAFlBpB,GAAK,EAE5B,CAIJ,OAAIqB,EAASA,EAAS,OAAS,CAAC,EAAEnB,CAAqB,EAAIkB,GACvDC,EAAS,KAAK,EAAE,EAEbA,CACX,CACJ,CC5Fe,MAAMK,CAAc,CAC/B,YAAY,CAAE,WAAAhB,EAAY,cAAAiB,GAAkB,CACxC,KAAK,WAAajB,EAClB,KAAK,IAAM,IAAID,EAAS,CACpB,WAAYkB,CACxB,CAAS,CACL,CACA,MAAM,wBAAwBC,EAAoBC,EAAwB,CACtE,IAAIC,EAAOD,EACNC,IACDA,GAAQ,MAAM,KAAK,WAAW,KAAI,GAAI,MAG1C,MAAMC,EAAwBD,EAAOF,EAC/BI,EAAc,MAAM,KAAK,WAAW,KAAKD,EAAuBH,CAAkB,EAExF,OAAOK,EAAMD,CAAW,CAC5B,CACA,MAAM,KAAKb,EAAQf,EAAU,CACzB,MAAM8B,EAAiB,MAAM,KAAK,IAAI,yBAAyBf,EAAQf,CAAQ,EACzE+B,EAAS,CAAA,EACf,QAASC,EAAW,EAAGA,EAAWF,EAAe,OAAS,EAAGE,GAAY,EAAG,CACxE,MAAMC,EAAqB,MAAM,KAAK,wBAAwBH,EAAeE,CAAQ,EAAE,CAAC,EAAGF,EAAeE,EAAW,CAAC,EAAE,CAAC,CAAC,EACpH,EAAG7B,CAAoB,EAAI2B,EAAeE,CAAQ,EAClDE,EAAe/B,GAAwBH,EAAW,EAAIA,EAAWG,EACjEgC,EAAY,KAAK,IAAInC,EAAWe,EAAQZ,EAAuB8B,EAAmB,MAAM,EAAI9B,EAC9F+B,GAAgB,GAAKA,EAAeD,EAAmB,QACvDF,EAAO,KAAKE,EAAmB,SAASC,EAAcC,CAAS,CAAC,CAExE,CACA,OAAOC,EAAiBL,CAAM,CAClC,CACJ,CChCe,MAAMM,UAA0BC,CAAa,CACxD,YAAY,CAAE,MAAAC,EAAO,KAAAC,EAAM,IAAAC,EAAK,QAAAC,EAAS,IAAAC,EAAK,QAAAC,GAAY,CACtD,MAAM,CAAE,MAAAL,EAAO,KAAAC,EAAM,IAAAC,EAAK,QAAAC,CAAO,CAAE,EAC/BH,GAASI,EAET,KAAK,MAAQ,IAAIE,EAAe,CAC5B,WAAYN,EACZ,cAAeI,CAC/B,CAAa,EAEIH,GAAQI,IAEb,KAAK,MAAQ,IAAIC,EAAe,CAC5B,WAAY,IAAIC,EAAUN,CAAI,EAC9B,cAAe,IAAIM,EAAUF,CAAO,CACpD,CAAa,EAET,CACJ,CClBe,MAAMG,UAA0BT,CAAa,CACxD,MAAM,UAAW,CACb,MAAMU,EAAgB,KAAK,QAAQ,eAAe,EAC5CC,EAAc,KAAK,QAAQ,aAAa,EACxCC,EAAc,KAAK,QAAQ,aAAa,EACxCC,EAAY,CACd,MAAOC,EAAAA,aAAaJ,EAAe,KAAK,aAAa,EACrD,IAAKI,EAAAA,aAAaH,EAAa,KAAK,aAAa,EACjD,IAAKG,EAAAA,aAAaF,EAAa,KAAK,aAAa,CAC7D,EACQ,MAAO,CAAE,MAAO,IAAIb,EAAkBc,CAAS,CAAC,CACpD,CACJ","x_google_ignoreList":[0,1,2,3,4]}