import{I as v}from"./main-G3gN6lip.js";import{B as b,f as T}from"./util-BTDNRxYH.js";import{B as w}from"./index-D3TbvS_u.js";import{u as m,ag as y}from"./index-DPMJgfAS.js";import{p as C}from"./parseLineByLine-Cz_4ZyEp.js";import{r as F}from"./rxjs-DiVqhxS9.js";class x extends w.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(e){const t=this.getConf("bedLocation"),o=await m.fetchAndMaybeUnzip(y.openLocation(t,this.pluginManager),e),s=[],a={};C.parseLineByLine(o,r=>{if(r.startsWith("#"))s.push(r);else{const g=r.indexOf("	"),p=r.slice(0,g);a[p]||(a[p]=[]),a[p].push(r)}return!0},e?.statusCallback);const l=s.join(`
`),i=this.getConf("autoSql"),n=new b({autoSql:i}),u=this.getConf("columnNames"),d=this.getConf("scoreColumn"),c=this.getConf("colRef"),f=this.getConf("colStart"),h=this.getConf("colEnd");return{header:l,features:a,parser:n,columnNames:u,scoreColumn:d,colRef:c,colStart:f,colEnd:h}}async loadData(e={}){return this.bedFeatures||(this.bedFeatures=this.loadDataP(e).catch(t=>{throw this.bedFeatures=void 0,t})),this.bedFeatures}async getRefNames(e={}){const{features:t}=await this.loadData(e);return Object.keys(t)}async getHeader(e={}){const{header:t}=await this.loadData(e);return t}async getNames(){const{header:e,columnNames:t}=await this.loadData();if(t.length)return t;const s=e.split(/\n|\r\n|\r/).filter(a=>!!a).at(-1);return s?.includes("	")?s.slice(1).split("	").map(a=>a.trim()):void 0}async loadFeatureIntervalTreeHelper(e){const{colRef:t,colStart:o,colEnd:s,features:a,parser:l,scoreColumn:i}=await this.loadData(),n=a[e];if(!n)return;const u=await this.getNames(),d=new v;for(let c=0;c<n.length;c++){const f=n[c],h=`${this.id}-${e}-${c}`,r=new m.SimpleFeature(T({line:f,colRef:t,colStart:o,colEnd:s,scoreColumn:i,parser:l,uniqueId:h,names:u}));d.insert([r.get("start"),r.get("end")],r)}return d}async loadFeatureIntervalTree(e){return this.intervalTrees[e]||(this.intervalTrees[e]=this.loadFeatureIntervalTreeHelper(e).catch(t=>{throw this.intervalTrees[e]=void 0,t})),this.intervalTrees[e]}getFeatures(e,t={}){return F.ObservableCreate(async o=>{const{start:s,end:a,refName:l}=e,i=await this.loadFeatureIntervalTree(l),n=i?.search([s,a]);if(n)for(const u of n)o.next(u);o.complete()},t.stopToken)}}x.capabilities=["getFeatures","getRefNames"];export{x as default};
//# sourceMappingURL=BedAdapter-Bra4kmpT.js.map
