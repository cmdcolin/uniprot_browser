{"version":3,"file":"TwoBitAdapter-BYG2t9Z3.js","sources":["../../node_modules/@gmod/twobit/esm/bigint-polyfill/pure.js","../../node_modules/@gmod/twobit/esm/bigint-polyfill/polyfill.js","../../node_modules/@gmod/twobit/esm/twoBitFile.js","../../node_modules/@jbrowse/plugin-sequence/esm/TwoBitAdapter/TwoBitAdapter.js"],"sourcesContent":["const BigInt32 = BigInt(32);\nexport function getBigInt64(dataView, byteOffset, littleEndian) {\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    return ((BigInt(dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask) <<\n        BigInt32) |\n        BigInt(dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n            dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask));\n}\nexport function getBigUint64(dataView, byteOffset, littleEndian) {\n    const a = dataView.getUint32(byteOffset, littleEndian);\n    const b = dataView.getUint32(byteOffset + 4, littleEndian);\n    const littleEndianMask = Number(!!littleEndian);\n    const bigEndianMask = Number(!littleEndian);\n    // This branch-less optimization is 77x faster than normal ternary operator.\n    // and only 3% slower than native implementation\n    // https://jsbench.me/p8kyhg1eqv/1\n    return ((BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n        BigInt(a * littleEndianMask + b * bigEndianMask));\n}\n//# sourceMappingURL=pure.js.map","import { getBigInt64, getBigUint64 } from \"./pure.js\";\nif (!('getBigInt64' in DataView)) {\n    DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n        return getBigInt64(this, byteOffset, littleEndian);\n    };\n}\nif (!('getBigUint64' in DataView)) {\n    DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n        return getBigUint64(this, byteOffset, littleEndian);\n    };\n}\n//# sourceMappingURL=polyfill.js.map","import { LocalFile } from 'generic-filehandle2';\nconst TWOBIT_MAGIC = 0x1a412743;\nconst twoBit = ['T', 'C', 'A', 'G'];\n// byteTo4Bases is an array of byteValue -> 'ACTG'\nconst byteTo4Bases = [];\nfor (let index = 0; index < 256; index++) {\n    byteTo4Bases.push(twoBit[(index >> 6) & 3] +\n        twoBit[(index >> 4) & 3] +\n        twoBit[(index >> 2) & 3] +\n        twoBit[index & 3]);\n}\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase());\nexport default class TwoBitFile {\n    /**\n     * @param {object} args\n     * @param {string} [args.path] filesystem path for the .2bit file to open\n     * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n     *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n     */\n    constructor({ filehandle, path, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else {\n            throw new Error('must supply path or filehandle');\n        }\n    }\n    async _detectEndianness() {\n        const buffer = await this.filehandle.read(8, 0);\n        const dataView = new DataView(buffer.buffer);\n        const magic = dataView.getInt32(0, true);\n        if (magic === TWOBIT_MAGIC) {\n            this.version = dataView.getInt32(0, true);\n        }\n        else {\n            throw new Error('not a 2bit file');\n        }\n    }\n    getHeader() {\n        if (!this.headerP) {\n            this.headerP = this._getHeader().catch((error) => {\n                this.headerP = undefined;\n                throw error;\n            });\n        }\n        return this.headerP;\n    }\n    async _getHeader() {\n        await this._detectEndianness();\n        const b = await this.filehandle.read(16, 0);\n        const le = true;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const magic = dataView.getInt32(offset, le);\n        offset += 4;\n        if (magic !== 0x1a412743) {\n            throw new Error(`Wrong magic number ${magic}`);\n        }\n        const version = dataView.getInt32(offset, le);\n        offset += 4;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const reserved = dataView.getUint32(offset, le);\n        return {\n            version,\n            magic,\n            sequenceCount,\n            reserved,\n        };\n    }\n    getIndex() {\n        if (!this.indexP) {\n            this.indexP = this._getIndex().catch((error) => {\n                this.indexP = undefined;\n                throw error;\n            });\n        }\n        return this.indexP;\n    }\n    async _getIndex() {\n        const header = await this.getHeader();\n        const maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));\n        const b = await this.filehandle.read(maxIndexLength, 8);\n        const le = true;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        let offset = 0;\n        const sequenceCount = dataView.getUint32(offset, le);\n        offset += 4;\n        // const reserved = dataView.getUint32(offset, le)\n        offset += 4;\n        const indexData = [];\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < sequenceCount; i++) {\n            const nameLength = dataView.getUint8(offset);\n            offset += 1;\n            const name = decoder.decode(b.subarray(offset, offset + nameLength));\n            offset += nameLength;\n            if (header.version === 1) {\n                const dataOffset = Number(dataView.getBigUint64(offset, le));\n                offset += 8;\n                indexData.push({ offset: dataOffset, name });\n            }\n            else {\n                const dataOffset = dataView.getUint32(offset, le);\n                offset += 4;\n                indexData.push({ offset: dataOffset, name });\n            }\n        }\n        return Object.fromEntries(indexData.map(({ name, offset }) => [name, offset]));\n    }\n    /**\n     * @returns for an array of string sequence names that are found in the file\n     */\n    async getSequenceNames() {\n        const index = await this.getIndex();\n        return Object.keys(index);\n    }\n    /**\n     * @returns object listing the lengths of all sequences like `{seqName:\n     * length, ...}`.\n     *\n     * note: this is a relatively slow operation especially if there are many\n     * refseqs in the file, if you can get this information from a different file\n     * e.g. a chrom.sizes file, it will be much faster\n     */\n    async getSequenceSizes() {\n        const index = await this.getIndex();\n        const seqNames = Object.keys(index);\n        const sizes = await Promise.all(Object.values(index).map(offset => this._getSequenceSize(offset)));\n        const returnObject = {};\n        for (const [index_, seqName] of seqNames.entries()) {\n            returnObject[seqName] = sizes[index_];\n        }\n        return returnObject;\n    }\n    /**\n     * @param seqName name of the sequence\n     *\n     * @returns sequence length, or undefined if it is not in the file\n     */\n    async getSequenceSize(seqName) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        return offset ? this._getSequenceSize(offset) : undefined;\n    }\n    async _getSequenceSize(offset) {\n        return this._record1(offset).then(f => f.dnaSize);\n    }\n    async _record1(offset2, len = 8) {\n        const b = await this.filehandle.read(len, offset2);\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const dnaSize = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        return { dnaSize, nBlockCount };\n    }\n    async _record2(offset2, len) {\n        const b = await this.filehandle.read(len, offset2);\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const nBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const nBlockStarts = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockStarts.push(elt);\n        }\n        const nBlockSizes = [];\n        for (let i = 0; i < nBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            nBlockSizes.push(elt);\n        }\n        const maskBlockCount = dataView.getUint32(offset, le);\n        return {\n            maskBlockCount,\n            nBlockSizes,\n            nBlockStarts,\n        };\n    }\n    async _record3(offset2, len) {\n        const b = await this.filehandle.read(len, offset2);\n        const le = true;\n        let offset = 0;\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length);\n        const maskBlockCount = dataView.getUint32(offset, le);\n        offset += 4;\n        const maskBlockStarts = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockStarts.push(elt);\n        }\n        const maskBlockSizes = [];\n        for (let i = 0; i < maskBlockCount; i++) {\n            const elt = dataView.getUint32(offset, le);\n            offset += 4;\n            maskBlockSizes.push(elt);\n        }\n        const reserved = dataView.getInt32(offset, le);\n        return {\n            maskBlockCount,\n            maskBlockSizes,\n            maskBlockStarts,\n            reserved,\n        };\n    }\n    async _getSequenceRecord(offset) {\n        const rec1 = await this._record1(offset);\n        const rec2DataLen = rec1.nBlockCount * 8 + 8;\n        const rec2 = await this._record2(offset + 4, rec2DataLen);\n        const rec3DataLen = rec2.maskBlockCount * 8 + 8;\n        const rec3 = await this._record3(offset + 4 + rec2DataLen - 4, rec3DataLen);\n        const rec = {\n            dnaSize: rec1.dnaSize,\n            nBlocks: {\n                starts: rec2.nBlockStarts,\n                sizes: rec2.nBlockSizes,\n            },\n            maskBlocks: {\n                starts: rec3.maskBlockStarts,\n                sizes: rec3.maskBlockSizes,\n            },\n            dnaPosition: offset + 4 + rec2DataLen - 4 + rec3DataLen,\n        };\n        return rec;\n    }\n    /**\n     * @param seqName name of the sequence you want\n     *\n     * @param [regionStart] optional 0-based half-open start of the sequence\n     * region to fetch.\n     *\n     * @param [regionEnd] optional 0-based half-open end of the sequence region\n     * to fetch. defaults to end of the sequence\n     *\n     * @returns for a string of sequence bases\n     */\n    async getSequence(seqName, regionStart = 0, regionEnd = Number.POSITIVE_INFINITY) {\n        const index = await this.getIndex();\n        const offset = index[seqName];\n        if (!offset) {\n            return undefined;\n        }\n        // fetch the record for the seq\n        const record = await this._getSequenceRecord(offset);\n        if (regionStart < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        // end defaults to the end of the sequence\n        if (regionEnd > record.dnaSize) {\n            regionEnd = record.dnaSize;\n        }\n        const nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);\n        const maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);\n        const baseBytesLen = Math.ceil((regionEnd - regionStart) / 4) + 1;\n        const baseBytesOffset = Math.floor(regionStart / 4);\n        const buffer = await this.filehandle.read(baseBytesLen, record.dnaPosition + baseBytesOffset);\n        let sequenceBases = '';\n        for (let genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {\n            // check whether we are currently masked\n            while (maskBlocks.length > 0 && maskBlocks[0].end <= genomicPosition) {\n                maskBlocks.shift();\n            }\n            const baseIsMasked = maskBlocks[0] &&\n                maskBlocks[0].start <= genomicPosition &&\n                maskBlocks[0].end > genomicPosition;\n            // process the N block if we have one\n            if (nBlocks[0] &&\n                genomicPosition >= nBlocks[0].start &&\n                genomicPosition < nBlocks[0].end) {\n                const currentNBlock = nBlocks.shift();\n                for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {\n                    sequenceBases += baseIsMasked ? 'n' : 'N';\n                }\n                genomicPosition -= 1;\n            }\n            else {\n                const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;\n                const subPosition = genomicPosition % 4;\n                const byte = buffer[bytePosition];\n                sequenceBases += baseIsMasked\n                    ? maskedByteTo4Bases[byte][subPosition]\n                    : byteTo4Bases[byte][subPosition];\n            }\n        }\n        return sequenceBases;\n    }\n    _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {\n        // find the start and end indexes of the blocks that match\n        let startIndex;\n        let endIndex;\n        for (const [index, blockStart] of blockStarts.entries()) {\n            const blockSize = blockSizes[index];\n            if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n                // block does not overlap the region\n                if (startIndex !== undefined) {\n                    endIndex = index;\n                    break;\n                }\n            }\n            else if (startIndex === undefined) {\n                startIndex = index;\n            } // block does overlap the region, record this if it is the first\n        }\n        if (startIndex === undefined) {\n            return [];\n        }\n        // now format some block objects to return\n        if (endIndex === undefined) {\n            endIndex = blockStarts.length;\n        }\n        const blocks = new Array(endIndex - startIndex);\n        for (let blockNumber = startIndex; blockNumber < endIndex; blockNumber += 1) {\n            blocks[blockNumber - startIndex] = {\n                start: blockStarts[blockNumber],\n                end: blockStarts[blockNumber] + blockSizes[blockNumber],\n                size: blockSizes[blockNumber],\n            };\n        }\n        return blocks;\n    }\n}\n//# sourceMappingURL=twoBitFile.js.map","import { TwoBitFile } from '@gmod/twobit';\nimport { readConfObject } from '@jbrowse/core/configuration';\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n    async initChromSizes() {\n        const conf = readConfObject(this.config, 'chromSizesLocation');\n        if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n            const file = openLocation(conf, this.pluginManager);\n            const data = await file.readFile('utf8');\n            return Object.fromEntries(data\n                .split(/\\n|\\r\\n|\\r/)\n                .filter(line => !!line.trim())\n                .map(line => {\n                const [name, length] = line.split('\\t');\n                return [name, +length];\n            }));\n        }\n        return undefined;\n    }\n    async setupPre() {\n        return {\n            twobit: new TwoBitFile({\n                filehandle: openLocation(this.getConf('twoBitLocation'), this.pluginManager),\n            }),\n            chromSizesData: await this.initChromSizes(),\n        };\n    }\n    async setup() {\n        if (!this.setupP) {\n            this.setupP = this.setupPre().catch((e) => {\n                this.setupP = undefined;\n                throw e;\n            });\n        }\n        return this.setupP;\n    }\n    async getRefNames() {\n        const { chromSizesData, twobit } = await this.setup();\n        return chromSizesData\n            ? Object.keys(chromSizesData)\n            : twobit.getSequenceNames();\n    }\n    async getRegions() {\n        const { chromSizesData, twobit } = await this.setup();\n        if (chromSizesData) {\n            return Object.keys(chromSizesData).map(refName => ({\n                refName,\n                start: 0,\n                end: chromSizesData[refName],\n            }));\n        }\n        else {\n            const refSizes = await twobit.getSequenceSizes();\n            return Object.keys(refSizes).map(refName => ({\n                refName,\n                start: 0,\n                end: refSizes[refName],\n            }));\n        }\n    }\n    getFeatures({ refName, start, end }) {\n        return ObservableCreate(async (observer) => {\n            const { twobit } = await this.setup();\n            const size = await twobit.getSequenceSize(refName);\n            const regionEnd = size !== undefined ? Math.min(size, end) : end;\n            const seq = await twobit.getSequence(refName, start, regionEnd);\n            if (seq) {\n                observer.next(new SimpleFeature({\n                    id: `${refName} ${start}-${regionEnd}`,\n                    data: { refName, start, end: regionEnd, seq },\n                }));\n            }\n            observer.complete();\n        });\n    }\n}\n"],"names":["BigInt32","getBigInt64","dataView","byteOffset","littleEndian","littleEndianMask","bigEndianMask","getBigUint64","a","b","TWOBIT_MAGIC","twoBit","byteTo4Bases","index","maskedByteTo4Bases","bases","TwoBitFile","filehandle","path","LocalFile","buffer","error","le","offset","magic","version","sequenceCount","reserved","header","maxIndexLength","indexData","decoder","i","nameLength","name","dataOffset","seqNames","sizes","returnObject","index_","seqName","f","offset2","len","dnaSize","nBlockCount","nBlockStarts","elt","nBlockSizes","maskBlockCount","maskBlockStarts","maskBlockSizes","rec1","rec2DataLen","rec2","rec3DataLen","rec3","regionStart","regionEnd","record","nBlocks","maskBlocks","baseBytesLen","baseBytesOffset","sequenceBases","genomicPosition","baseIsMasked","currentNBlock","bytePosition","subPosition","byte","blockStarts","blockSizes","startIndex","endIndex","blockStart","blockSize","blocks","blockNumber","TwoBitAdapter","BaseSequenceAdapter","conf","readConfObject","data","openLocation","line","length","chromSizesData","twobit","refName","refSizes","start","end","ObservableCreate","observer","size","seq","SimpleFeature"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}