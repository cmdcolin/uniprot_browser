{"version":3,"file":"unzip-OY3UkAtn.js","sources":["../../node_modules/@gmod/bgzf-filehandle/esm/util.js","../../node_modules/@gmod/bgzf-filehandle/esm/unzip.js"],"sourcesContent":["export function sum(array) {\n    let sum = 0;\n    for (const entry of array) {\n        sum += entry.length;\n    }\n    return sum;\n}\nexport function concatUint8Array(args) {\n    const mergedArray = new Uint8Array(sum(args));\n    let offset = 0;\n    for (const entry of args) {\n        mergedArray.set(entry, offset);\n        offset += entry.length;\n    }\n    return mergedArray;\n}\n//# sourceMappingURL=util.js.map","import pkg from 'pako';\nimport { concatUint8Array } from \"./util.js\";\n//@ts-ignore\nconst { Z_SYNC_FLUSH, Inflate } = pkg;\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than one bgzf\n// block, so export an unzip function that uses pako directly if we are running\n// in a browser.\nexport async function unzip(inputData) {\n    try {\n        let strm;\n        let pos = 0;\n        let inflator;\n        const blocks = [];\n        do {\n            const remainingInput = inputData.subarray(pos);\n            inflator = new Inflate();\n            ({ strm } = inflator);\n            inflator.push(remainingInput, Z_SYNC_FLUSH);\n            if (inflator.err) {\n                throw new Error(inflator.msg);\n            }\n            pos += strm.next_in;\n            blocks.push(inflator.result);\n        } while (strm.avail_in);\n        return concatUint8Array(blocks);\n    }\n    catch (e) {\n        // return a slightly more informative error message\n        if (/incorrect header check/.exec(`${e}`)) {\n            throw new Error('problem decompressing block: incorrect gzip header check');\n        }\n        throw e;\n    }\n}\n// keeps track of the position of compressed blocks in terms of file offsets,\n// and a decompressed equivalent\n//\n// also slices (0,minv.dataPosition) and (maxv.dataPosition,end) off\nexport async function unzipChunkSlice(inputData, chunk) {\n    try {\n        let strm;\n        const { minv, maxv } = chunk;\n        let cpos = minv.blockPosition;\n        let dpos = minv.dataPosition;\n        const chunks = [];\n        const cpositions = [];\n        const dpositions = [];\n        let i = 0;\n        do {\n            const remainingInput = inputData.subarray(cpos - minv.blockPosition);\n            const inflator = new Inflate();\n            ({ strm } = inflator);\n            inflator.push(remainingInput, Z_SYNC_FLUSH);\n            if (inflator.err) {\n                throw new Error(inflator.msg);\n            }\n            const buffer = inflator.result;\n            chunks.push(buffer);\n            let len = buffer.length;\n            cpositions.push(cpos);\n            dpositions.push(dpos);\n            if (chunks.length === 1 && minv.dataPosition) {\n                // this is the first chunk, trim it\n                chunks[0] = chunks[0].subarray(minv.dataPosition);\n                len = chunks[0].length;\n            }\n            const origCpos = cpos;\n            cpos += strm.next_in;\n            dpos += len;\n            if (origCpos >= maxv.blockPosition) {\n                // this is the last chunk, trim it and stop decompressing. note if it is\n                // the same block is minv it subtracts that already trimmed part of the\n                // slice length\n                chunks[i] = chunks[i].subarray(0, maxv.blockPosition === minv.blockPosition\n                    ? maxv.dataPosition - minv.dataPosition + 1\n                    : maxv.dataPosition + 1);\n                cpositions.push(cpos);\n                dpositions.push(dpos);\n                break;\n            }\n            i++;\n        } while (strm.avail_in);\n        return {\n            buffer: concatUint8Array(chunks),\n            cpositions,\n            dpositions,\n        };\n    }\n    catch (e) {\n        // return a slightly more informative error message\n        if (/incorrect header check/.exec(`${e}`)) {\n            throw new Error('problem decompressing block: incorrect gzip header check');\n        }\n        throw e;\n    }\n}\n//# sourceMappingURL=unzip.js.map"],"names":["sum","array","entry","concatUint8Array","args","mergedArray","offset","Z_SYNC_FLUSH","Inflate","pkg","unzip","inputData","strm","pos","inflator","blocks","remainingInput","e","unzipChunkSlice","chunk","minv","maxv","cpos","dpos","chunks","cpositions","dpositions","i","buffer","len","origCpos"],"mappings":"wCAAO,SAASA,EAAIC,EAAO,CACvB,IAAID,EAAM,EACV,UAAWE,KAASD,EAChBD,GAAOE,EAAM,OAEjB,OAAOF,CACX,CACO,SAASG,EAAiBC,EAAM,CACnC,MAAMC,EAAc,IAAI,WAAWL,EAAII,CAAI,CAAC,EAC5C,IAAIE,EAAS,EACb,UAAWJ,KAASE,EAChBC,EAAY,IAAIH,EAAOI,CAAM,EAC7BA,GAAUJ,EAAM,OAEpB,OAAOG,CACX,CCZA,KAAM,CAAE,aAAAE,EAAc,QAAAC,CAAO,EAAKC,EAK3B,eAAeC,EAAMC,EAAW,CACnC,GAAI,CACA,IAAIC,EACAC,EAAM,EACNC,EACJ,MAAMC,EAAS,CAAA,EACf,EAAG,CACC,MAAMC,EAAiBL,EAAU,SAASE,CAAG,EAI7C,GAHAC,EAAW,IAAIN,EACd,CAAE,KAAAI,CAAI,EAAKE,EACZA,EAAS,KAAKE,EAAgBT,CAAY,EACtCO,EAAS,IACT,MAAM,IAAI,MAAMA,EAAS,GAAG,EAEhCD,GAAOD,EAAK,QACZG,EAAO,KAAKD,EAAS,MAAM,CAC/B,OAASF,EAAK,UACd,OAAOT,EAAiBY,CAAM,CAClC,OACOE,EAAG,CAEN,KAAI,yBAAyB,KAAK,GAAGA,CAAC,EAAE,EAC9B,IAAI,MAAM,0DAA0D,EAExEA,CACV,CACJ,CAKO,eAAeC,EAAgBP,EAAWQ,EAAO,CACpD,GAAI,CACA,IAAIP,EACJ,KAAM,CAAE,KAAAQ,EAAM,KAAAC,CAAI,EAAKF,EACvB,IAAIG,EAAOF,EAAK,cACZG,EAAOH,EAAK,aAChB,MAAMI,EAAS,CAAA,EACTC,EAAa,CAAA,EACbC,EAAa,CAAA,EACnB,IAAIC,EAAI,EACR,EAAG,CACC,MAAMX,EAAiBL,EAAU,SAASW,EAAOF,EAAK,aAAa,EAC7DN,EAAW,IAAIN,EAGrB,GAFC,CAAE,KAAAI,CAAI,EAAKE,EACZA,EAAS,KAAKE,EAAgBT,CAAY,EACtCO,EAAS,IACT,MAAM,IAAI,MAAMA,EAAS,GAAG,EAEhC,MAAMc,EAASd,EAAS,OACxBU,EAAO,KAAKI,CAAM,EAClB,IAAIC,EAAMD,EAAO,OACjBH,EAAW,KAAKH,CAAI,EACpBI,EAAW,KAAKH,CAAI,EAChBC,EAAO,SAAW,GAAKJ,EAAK,eAE5BI,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAE,SAASJ,EAAK,YAAY,EAChDS,EAAML,EAAO,CAAC,EAAE,QAEpB,MAAMM,EAAWR,EAGjB,GAFAA,GAAQV,EAAK,QACbW,GAAQM,EACJC,GAAYT,EAAK,cAAe,CAIhCG,EAAOG,CAAC,EAAIH,EAAOG,CAAC,EAAE,SAAS,EAAGN,EAAK,gBAAkBD,EAAK,cACxDC,EAAK,aAAeD,EAAK,aAAe,EACxCC,EAAK,aAAe,CAAC,EAC3BI,EAAW,KAAKH,CAAI,EACpBI,EAAW,KAAKH,CAAI,EACpB,KACJ,CACAI,GACJ,OAASf,EAAK,UACd,MAAO,CACH,OAAQT,EAAiBqB,CAAM,EAC/B,WAAAC,EACA,WAAAC,CACZ,CACI,OACOT,EAAG,CAEN,KAAI,yBAAyB,KAAK,GAAGA,CAAC,EAAE,EAC9B,IAAI,MAAM,0DAA0D,EAExEA,CACV,CACJ","x_google_ignoreList":[0,1]}