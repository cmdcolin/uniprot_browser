{"version":3,"file":"index-6ayqgJsu.js","sources":["../../node_modules/@gmod/vcf/esm/parseGenotypesOnly.js","../../node_modules/@gmod/vcf/esm/parseMetaString.js","../../node_modules/@gmod/vcf/esm/vcfReserved.js","../../node_modules/@gmod/vcf/esm/parse.js","../../node_modules/@jbrowse/plugin-variants/esm/VcfFeature/index.js"],"sourcesContent":["export function parseGenotypesOnly(format, prerest, samples) {\n    const rest = prerest.split('\\t');\n    const genotypes = {};\n    let i = 0;\n    if (format.includes('GT')) {\n        const formatSplit = format.split(':');\n        if (formatSplit.length === 1) {\n            for (const sample of samples) {\n                genotypes[sample] = rest[i++];\n            }\n        }\n        else {\n            const gtIndex = formatSplit.indexOf('GT');\n            if (gtIndex === 0) {\n                for (const sample of samples) {\n                    const val = rest[i++];\n                    const idx = val.indexOf(':');\n                    genotypes[sample] = idx !== -1 ? val.slice(0, idx) : val;\n                }\n            }\n            else {\n                for (const sample of samples) {\n                    const val = rest[i++].split(':');\n                    genotypes[sample] = val[gtIndex];\n                }\n            }\n        }\n    }\n    return genotypes;\n}\n//# sourceMappingURL=parseGenotypesOnly.js.map","// constructed with the assistance of claude AI\n//\n// I first prompted it with a regex that splits a comma separated string with\n// awareness of quotation from this stackoverflow queston\n// https://stackoverflow.com/a/18893443/2129219, and asked it to add support\n// for square brackets\n//\n// it undid the regex into serial logic and the result was this function\nfunction customSplit(str) {\n    const result = [];\n    let current = '';\n    let inQuotes = false;\n    let inBrackets = false;\n    for (const char of str) {\n        if (char === '\"') {\n            inQuotes = !inQuotes;\n            current += char;\n        }\n        else if (char === '[') {\n            inBrackets = true;\n            current += char;\n        }\n        else if (char === ']') {\n            inBrackets = false;\n            current += char;\n        }\n        else if (char === ',' && !inQuotes && !inBrackets) {\n            result.push(current.trim());\n            current = '';\n        }\n        else {\n            current += char;\n        }\n    }\n    if (current) {\n        result.push(current.trim());\n    }\n    return result;\n}\nfunction splitFirst(str, split) {\n    const index = str.indexOf(split);\n    return [str.slice(0, index), str.slice(index + 1)];\n}\nexport function parseMetaString(metaString) {\n    const inside = metaString.replace(/^<|>$/g, '');\n    return Object.fromEntries(customSplit(inside).map(f => {\n        const [key, val] = splitFirst(f, '=');\n        if (val && val.startsWith('[') && val.endsWith(']')) {\n            return [\n                key,\n                val\n                    .slice(1, -1)\n                    .split(',')\n                    .map(f => f.trim()),\n            ];\n        }\n        else if (val && val.startsWith('\"') && val.endsWith('\"')) {\n            return [key, val.slice(1, -1)];\n        }\n        else {\n            return [key, val?.replaceAll(/^\"|\"$/g, '')];\n        }\n    }));\n}\n//# sourceMappingURL=parseMetaString.js.map","export default {\n    // INFO fields\n    InfoFields: {\n        // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n        AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n        AC: {\n            Number: 'A',\n            Type: 'Integer',\n            Description: 'Allele count in genotypes, for each ALT allele, in the same order as listed',\n        },\n        AD: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Total read depth for each allele',\n        },\n        ADF: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the forward strand',\n        },\n        ADR: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the reverse strand',\n        },\n        AF: {\n            Number: 'A',\n            Type: 'Float',\n            Description: 'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)',\n        },\n        AN: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Total number of alleles in called genotypes',\n        },\n        BQ: {\n            Number: 1,\n            Type: 'Float',\n            Description: 'RMS base quality',\n        },\n        CIGAR: {\n            Number: 1,\n            Type: 'Float',\n            Description: 'Cigar string describing how to align an alternate allele to the reference allele',\n        },\n        DB: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'dbSNP membership',\n        },\n        DP: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'combined depth across samples',\n        },\n        END: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'End position (for use with symbolic alleles)',\n        },\n        H2: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'HapMap2 membership',\n        },\n        H3: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'HapMap3 membership',\n        },\n        MQ: {\n            Number: 1,\n            Type: null,\n            Description: 'RMS mapping quality',\n        },\n        MQ0: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Number of MAPQ == 0 reads',\n        },\n        NS: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Number of samples with data',\n        },\n        SB: {\n            Number: 4,\n            Type: 'Integer',\n            Description: 'Strand bias',\n        },\n        SOMATIC: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Somatic mutation (for cancer genomics)',\n        },\n        VALIDATED: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Validated by follow-up experiment',\n        },\n        '1000G': {\n            Number: 0,\n            Type: 'Flag',\n            Description: '1000 Genomes membership',\n        },\n        // specifically for structural variants\n        IMPRECISE: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Imprecise structural variation',\n        },\n        NOVEL: {\n            Number: 0,\n            Type: 'Flag',\n            Description: 'Indicates a novel structural variation',\n        },\n        // For precise variants, END is POS + length of REF allele - 1,\n        // and the for imprecise variants the corresponding best estimate.\n        SVTYPE: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Type of structural variant',\n        },\n        // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n        // be derived from the REF/ALT fields but is useful for filtering.\n        SVLEN: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Difference in length between REF and ALT alleles',\n        },\n        // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n        // have positive values, shorter ALT alleles (e.g. deletions)\n        // have negative values.\n        CIPOS: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around POS for imprecise variants',\n        },\n        CIEND: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around END for imprecise variants',\n        },\n        HOMLEN: {\n            Type: 'Integer',\n            Description: 'Length of base pair identical micro-homology at event breakpoints',\n        },\n        HOMSEQ: {\n            Type: 'String',\n            Description: 'Sequence of base pair identical micro-homology at event breakpoints',\n        },\n        BKPTID: {\n            Type: 'String',\n            Description: 'ID of the assembled alternate allele in the assembly file',\n        },\n        // For precise variants, the consensus sequence the alternate allele assembly\n        // is derivable from the REF and ALT fields. However, the alternate allele\n        // assembly file may contain additional information about the characteristics\n        // of the alt allele contigs.\n        MEINFO: {\n            Number: 4,\n            Type: 'String',\n            Description: 'Mobile element info of the form NAME,START,END,POLARITY',\n        },\n        METRANS: {\n            Number: 4,\n            Type: 'String',\n            Description: 'Mobile element transduction info of the form CHR,START,END,POLARITY',\n        },\n        DGVID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in Database of Genomic Variation',\n        },\n        DBVARID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in DBVAR',\n        },\n        DBRIPID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of this element in DBRIP',\n        },\n        MATEID: {\n            Number: null,\n            Type: 'String',\n            Description: 'ID of mate breakends',\n        },\n        PARID: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of partner breakend',\n        },\n        EVENT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'ID of event associated to breakend',\n        },\n        CILEN: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around the inserted material between breakend',\n        },\n        DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n        CN: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Copy number of segment containing breakend',\n        },\n        CNADJ: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Copy number of adjacency',\n        },\n        CICN: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Confidence interval around copy number for the segment',\n        },\n        CICNADJ: {\n            Number: null,\n            Type: 'Integer',\n            Description: 'Confidence interval around copy number for the adjacency',\n        },\n    },\n    // FORMAT fields\n    GenotypeFields: {\n        // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n        AD: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele',\n        },\n        ADF: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the forward strand',\n        },\n        ADR: {\n            Number: 'R',\n            Type: 'Integer',\n            Description: 'Read depth for each allele on the reverse strand',\n        },\n        DP: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Read depth',\n        },\n        EC: {\n            Number: 'A',\n            Type: 'Integer',\n            Description: 'Expected alternate allele counts',\n        },\n        FT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Filter indicating if this genotype was \"called\"',\n        },\n        GL: {\n            Number: 'G',\n            Type: 'Float',\n            Description: 'Genotype likelihoods',\n        },\n        GP: {\n            Number: 'G',\n            Type: 'Float',\n            Description: 'Genotype posterior probabilities',\n        },\n        GQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Conditional genotype quality',\n        },\n        GT: {\n            Number: 1,\n            Type: 'String',\n            Description: 'Genotype',\n        },\n        HQ: {\n            Number: 2,\n            Type: 'Integer',\n            Description: 'Haplotype quality',\n        },\n        MQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'RMS mapping quality',\n        },\n        PL: {\n            Number: 'G',\n            Type: 'Integer',\n            Description: 'Phred-scaled genotype likelihoods rounded to the closest integer',\n        },\n        PQ: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Phasing quality',\n        },\n        PS: {\n            Number: 1,\n            Type: 'Integer',\n            Description: 'Phase set',\n        },\n    },\n    // ALT fields\n    AltTypes: {\n        DEL: {\n            Description: 'Deletion relative to the reference',\n        },\n        INS: {\n            Description: 'Insertion of novel sequence relative to the reference',\n        },\n        DUP: {\n            Description: 'Region of elevated copy number relative to the reference',\n        },\n        INV: {\n            Description: 'Inversion of reference sequence',\n        },\n        CNV: {\n            Description: 'Copy number variable region (may be both deletion and duplication)',\n        },\n        'DUP:TANDEM': {\n            Description: 'Tandem duplication',\n        },\n        'DEL:ME': {\n            Description: 'Deletion of mobile element relative to the reference',\n        },\n        'INS:ME': {\n            Description: 'Insertion of a mobile element relative to the reference',\n        },\n        NON_REF: {\n            Description: 'Represents any possible alternative allele at this location',\n        },\n        '*': {\n            Description: 'Represents any possible alternative allele at this location',\n        },\n    },\n    // FILTER fields\n    FilterTypes: {\n        PASS: {\n            Description: 'Passed all filters',\n        },\n    },\n};\n//# sourceMappingURL=vcfReserved.js.map","import { parseGenotypesOnly } from \"./parseGenotypesOnly.js\";\nimport { parseMetaString } from \"./parseMetaString.js\";\nimport vcfReserved from \"./vcfReserved.js\";\nfunction decodeURIComponentNoThrow(uri) {\n    try {\n        return decodeURIComponent(uri);\n    }\n    catch (_e) {\n        // avoid throwing exception on a failure to decode URI component\n        return uri;\n    }\n}\n/**\n * Class representing a VCF parser, instantiated with the VCF header.\n *\n * @param {object} args\n *\n * @param {string} args.header - The VCF header. Supports both LF and CRLF\n * newlines.\n *\n * @param {boolean} args.strict - Whether to parse in strict mode or not\n * (default true)\n */\nexport default class VCFParser {\n    constructor({ header = '', strict = true, }) {\n        if (!header.length) {\n            throw new Error('empty header received');\n        }\n        const headerLines = header.split(/[\\r\\n]+/).filter(Boolean);\n        if (!headerLines.length) {\n            throw new Error('no non-empty header lines specified');\n        }\n        this.strict = strict;\n        this.metadata = JSON.parse(JSON.stringify({\n            INFO: vcfReserved.InfoFields,\n            FORMAT: vcfReserved.GenotypeFields,\n            ALT: vcfReserved.AltTypes,\n            FILTER: vcfReserved.FilterTypes,\n        }));\n        let lastLine;\n        headerLines.forEach(line => {\n            if (!line.startsWith('#')) {\n                throw new Error(`Bad line in header:\\n${line}`);\n            }\n            else if (line.startsWith('##')) {\n                this.parseMetadata(line);\n            }\n            else {\n                lastLine = line;\n            }\n        });\n        if (!lastLine) {\n            throw new Error('No format line found in header');\n        }\n        const fields = lastLine.trim().split('\\t');\n        const thisHeader = fields.slice(0, 8);\n        const correctHeader = [\n            '#CHROM',\n            'POS',\n            'ID',\n            'REF',\n            'ALT',\n            'QUAL',\n            'FILTER',\n            'INFO',\n        ];\n        if (fields.length < 8) {\n            throw new Error(`VCF header missing columns:\\n${lastLine}`);\n        }\n        else if (thisHeader.length !== correctHeader.length ||\n            !thisHeader.every((value, index) => value === correctHeader[index])) {\n            throw new Error(`VCF column headers not correct:\\n${lastLine}`);\n        }\n        this.samples = fields.slice(9);\n    }\n    parseSamples(format, prerest) {\n        const genotypes = {};\n        if (format) {\n            const rest = prerest.split('\\t');\n            const formatKeys = format.split(':');\n            const isNumberType = formatKeys.map(key => {\n                const r = this.getMetadata('FORMAT', key, 'Type');\n                return r === 'Integer' || r === 'Float';\n            });\n            for (let i = 0; i < this.samples.length; i++) {\n                const sample = this.samples[i];\n                genotypes[sample] = {};\n                const columns = rest[i].split(':');\n                for (let j = 0; j < columns.length; j++) {\n                    const val = columns[j];\n                    genotypes[sample][formatKeys[j]] =\n                        val === '' || val === '.'\n                            ? undefined\n                            : val\n                                .split(',')\n                                .map(ent => ent === '.' ? undefined : isNumberType[j] ? +ent : ent);\n                }\n            }\n        }\n        return genotypes;\n    }\n    /**\n     * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n     * properties to the object.\n     *\n     * @param {string} line - A line from the VCF. Supports both LF and CRLF\n     * newlines.\n     */\n    parseMetadata(line) {\n        const match = /^##(.+?)=(.*)/.exec(line.trim());\n        if (!match) {\n            throw new Error(`Line is not a valid metadata line: ${line}`);\n        }\n        const [metaKey, metaVal] = match.slice(1, 3);\n        const r = metaKey;\n        if (metaVal?.startsWith('<')) {\n            if (!(r in this.metadata)) {\n                this.metadata[r] = {};\n            }\n            const [id, keyVals] = this.parseStructuredMetaVal(metaVal);\n            if (id) {\n                // if there is an ID field in the <> metadata\n                // e.g. ##INFO=<ID=AF_ESP,...>\n                ;\n                this.metadata[r][id] = keyVals;\n            }\n            else {\n                // if there is not an ID field in the <> metadata\n                // e.g. ##ID=<Description=\"ClinVar Variation ID\">\n                this.metadata[r] = keyVals;\n            }\n        }\n        else {\n            this.metadata[r] = metaVal;\n        }\n    }\n    /**\n     * Parse a VCF header structured meta string (i.e. a meta value that starts\n     * with \"<ID=...\")\n     *\n     * @param {string} metaVal - The VCF metadata value\n     *\n     * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n     * and 2) an object with the other key-value pairs in the metadata\n     */\n    parseStructuredMetaVal(metaVal) {\n        const keyVals = parseMetaString(metaVal);\n        const id = keyVals.ID;\n        delete keyVals.ID;\n        if ('Number' in keyVals) {\n            if (!Number.isNaN(Number(keyVals.Number))) {\n                keyVals.Number = Number(keyVals.Number);\n            }\n        }\n        return [id, keyVals];\n    }\n    /**\n     * Get metadata filtered by the elements in args. For example, can pass\n     * ('INFO', 'DP') to only get info on an metadata tag that was like\n     * \"##INFO=<ID=DP,...>\"\n     *\n     * @param  {...string} args - List of metadata filter strings.\n     *\n     * @returns {any} An object, string, or number, depending on the filtering\n     */\n    getMetadata(...args) {\n        let filteredMetadata = this.metadata;\n        for (const arg of args) {\n            filteredMetadata = filteredMetadata[arg];\n            if (!filteredMetadata) {\n                return filteredMetadata;\n            }\n        }\n        return filteredMetadata;\n    }\n    /**\n     * Parse a VCF line into an object like\n     *\n     * ```typescript\n     * {\n     *   CHROM: 'contigA',\n     *   POS: 3000,\n     *   ID: ['rs17883296'],\n     *   REF: 'G',\n     *   ALT: ['T', 'A'],\n     *   QUAL: 100,\n     *   FILTER: 'PASS',\n     *   INFO: {\n     *     NS: [3],\n     *     DP: [14],\n     *     AF: [0.5],\n     *     DB: true,\n     *     XYZ: ['5'],\n     *   },\n     *   SAMPLES: () => ({\n     *     HG00096: {\n     *       GT: ['0|0'],\n     *       AP: ['0.000', '0.000'],\n     *     }\n     *   }),\n     *   GENOTYPES: () => ({\n     *     HG00096: '0|0'\n     *   })\n     * }\n     * ```\n     *\n     * SAMPLES and GENOTYPES methods are functions instead of static data fields\n     * because it avoids parsing the potentially long list of samples from e.g.\n     * 1000 genotypes data unless requested.\n     *\n     * The SAMPLES function gives all info about the samples\n     *\n     * The GENOTYPES function only extracts the raw GT string if it exists, for\n     * potentially optimized parsing by programs that need it\n     *\n     * @param {string} line - A string of a line from a VCF\n     */\n    parseLine(line) {\n        let currChar = 0;\n        for (let currField = 0; currChar < line.length; currChar += 1) {\n            if (line[currChar] === '\\t') {\n                currField += 1;\n            }\n            if (currField === 9) {\n                // reached genotypes, rest of fields are evaluated lazily\n                break;\n            }\n        }\n        const fields = line.slice(0, currChar).split('\\t');\n        const rest = line.slice(currChar + 1);\n        const [CHROM, POS, ID, REF, ALT, QUAL, FILTER] = fields;\n        const chrom = CHROM;\n        const pos = +POS;\n        const id = ID === '.' ? undefined : ID.split(';');\n        const ref = REF;\n        const alt = ALT === '.' ? undefined : ALT.split(',');\n        const qual = QUAL === '.' ? undefined : +QUAL;\n        const filter = FILTER === '.' ? undefined : FILTER.split(';');\n        const format = fields[8];\n        if (this.strict && !fields[7]) {\n            throw new Error(\"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\");\n        }\n        const hasDecode = fields[7]?.includes('%');\n        const info = fields[7] === undefined || fields[7] === '.'\n            ? {}\n            : Object.fromEntries(fields[7].split(';').map(r => {\n                const [key, val] = r.split('=');\n                const items = val\n                    ?.split(',')\n                    .map(val => (val === '.' ? undefined : val))\n                    .map(f => (f && hasDecode ? decodeURIComponentNoThrow(f) : f));\n                const itemType = this.getMetadata('INFO', key, 'Type');\n                if (itemType === 'Integer' || itemType === 'Float') {\n                    return [\n                        key,\n                        items?.map(val => val === undefined ? undefined : Number(val)),\n                    ];\n                }\n                else if (itemType === 'Flag') {\n                    return [key, true];\n                }\n                else {\n                    // ?? true interpret as flag if undefined\n                    return [key, items ?? true];\n                }\n            }));\n        return {\n            CHROM: chrom,\n            POS: pos,\n            ALT: alt,\n            INFO: info,\n            REF: ref,\n            FILTER: filter && filter.length === 1 && filter[0] === 'PASS' ? 'PASS' : filter,\n            ID: id,\n            QUAL: qual,\n            FORMAT: format,\n            SAMPLES: () => this.parseSamples(fields[8] ?? '', rest),\n            GENOTYPES: () => parseGenotypesOnly(fields[8] ?? '', rest, this.samples),\n        };\n    }\n}\n//# sourceMappingURL=parse.js.map","import { getSOTermAndDescription } from './util';\nfunction dataFromVariant(variant, parser) {\n    const { REF = '', ALT, POS, CHROM, ID } = variant;\n    const start = POS - 1;\n    const [type, description] = getSOTermAndDescription(REF, ALT, parser);\n    return {\n        refName: CHROM,\n        start,\n        end: getEnd(variant),\n        description,\n        type,\n        name: ID === null || ID === void 0 ? void 0 : ID.join(','),\n    };\n}\nfunction getEnd(variant) {\n    const { POS, REF = '', ALT } = variant;\n    const isTRA = ALT === null || ALT === void 0 ? void 0 : ALT.includes('<TRA>');\n    const start = POS - 1;\n    const isSymbolic = ALT === null || ALT === void 0 ? void 0 : ALT.some(f => f.includes('<'));\n    if (isSymbolic) {\n        const info = variant.INFO;\n        if (info.END && !isTRA) {\n            return +info.END[0];\n        }\n    }\n    return start + REF.length;\n}\nexport default class VCFFeature {\n    constructor(args) {\n        this.variant = args.variant;\n        this.parser = args.parser;\n        this.data = dataFromVariant(this.variant, this.parser);\n        this._id = args.id;\n    }\n    get(field) {\n        var _a;\n        return field === 'samples'\n            ? this.variant.SAMPLES()\n            : field === 'genotypes'\n                ? this.variant.GENOTYPES()\n                : ((_a = this.data[field]) !== null && _a !== void 0 ? _a : this.variant[field]);\n    }\n    parent() {\n        return undefined;\n    }\n    children() {\n        return undefined;\n    }\n    id() {\n        return this._id;\n    }\n    toJSON() {\n        const { SAMPLES, GENOTYPES, ...rest } = this.variant;\n        return {\n            uniqueId: this._id,\n            ...rest,\n            ...this.data,\n            samples: this.variant.SAMPLES(),\n        };\n    }\n}\n"],"names":["parseGenotypesOnly","format","prerest","samples","rest","genotypes","i","formatSplit","sample","gtIndex","val","idx","customSplit","str","result","current","inQuotes","inBrackets","char","splitFirst","split","index","parseMetaString","metaString","inside","f","key","vcfReserved","decodeURIComponentNoThrow","uri","VCFParser","header","strict","headerLines","lastLine","line","fields","thisHeader","correctHeader","value","formatKeys","isNumberType","r","columns","j","ent","match","metaKey","metaVal","id","keyVals","args","filteredMetadata","arg","currChar","currField","CHROM","POS","ID","REF","ALT","QUAL","FILTER","chrom","pos","ref","alt","qual","filter","hasDecode","info","items","itemType","dataFromVariant","variant","parser","start","type","description","getSOTermAndDescription","getEnd","isTRA","VCFFeature","field","_a","SAMPLES","GENOTYPES"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}