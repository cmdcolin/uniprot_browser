{"version":3,"file":"tabixIndexedFile-Daod8iGq.js","sources":["../../node_modules/@gmod/tabix/esm/chunk.js","../../node_modules/@gmod/tabix/esm/indexFile.js","../../node_modules/@gmod/tabix/esm/long.js","../../node_modules/@gmod/tabix/esm/util.js","../../node_modules/@gmod/tabix/esm/virtualOffset.js","../../node_modules/@gmod/tabix/esm/csi.js","../../node_modules/@gmod/tabix/esm/tbi.js","../../node_modules/@gmod/tabix/esm/tabixIndexedFile.js"],"sourcesContent":["// little class representing a chunk in the index\nexport default class Chunk {\n    constructor(minv, maxv, bin, fetchedSize) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\n//# sourceMappingURL=chunk.js.map","export default class IndexFile {\n    constructor({ filehandle, renameRefSeqs = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeqs;\n    }\n    async getMetadata(opts = {}) {\n        const { indices: _indices, ...rest } = await this.parse(opts);\n        return rest;\n    }\n    _findFirstData(currentFdl, virtualOffset) {\n        if (currentFdl) {\n            return currentFdl.compareTo(virtualOffset) > 0\n                ? virtualOffset\n                : currentFdl;\n        }\n        else {\n            return virtualOffset;\n        }\n    }\n    async parse(opts = {}) {\n        if (!this.parseP) {\n            this.parseP = this._parse(opts).catch((error) => {\n                this.parseP = undefined;\n                throw error;\n            });\n        }\n        return this.parseP;\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        const idx = await this.parse(opts);\n        return !!idx.indices[seqId]?.binIndex;\n    }\n}\n//# sourceMappingURL=indexFile.js.map","export const TWO_PWR_16_DBL = 1 << 16;\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nexport function longFromBytesToUnsigned(source, i = 0) {\n    const low = source[i] |\n        (source[i + 1] << 8) |\n        (source[i + 2] << 16) |\n        (source[i + 3] << 24);\n    const high = source[i + 4] |\n        (source[i + 5] << 8) |\n        (source[i + 6] << 16) |\n        (source[i + 7] << 24);\n    return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0);\n}\n//# sourceMappingURL=long.js.map","class AbortError extends Error {\n}\n/**\n * Properly check if the given AbortSignal is aborted. Per the standard, if the\n * signal reads as aborted, this function throws either a DOMException\n * AbortError, or a regular error with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted`\n * attribute\n *\n * @returns nothing\n */\nexport function checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        if (typeof DOMException === 'undefined') {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n        else {\n            throw new DOMException('aborted', 'AbortError');\n        }\n    }\n}\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexport function canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexport function optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort(function (c0, c1) {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif;\n    });\n    for (const chunk of chunks) {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === undefined) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n    }\n    return mergedChunks;\n}\n//# sourceMappingURL=util.js.map","export default class VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n}\nexport function fromBytes(bytes, offset = 0) {\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\n//# sourceMappingURL=virtualOffset.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport Chunk from \"./chunk.js\";\nimport IndexFile from \"./indexFile.js\";\nimport { longFromBytesToUnsigned } from \"./long.js\";\nimport { optimizeChunks } from \"./util.js\";\nimport VirtualOffset, { fromBytes } from \"./virtualOffset.js\";\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nconst formats = {\n    0: 'generic',\n    1: 'SAM',\n    2: 'VCF',\n};\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nexport default class CSI extends IndexFile {\n    constructor(args) {\n        super(args);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return -1;\n        }\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    indexCov() {\n        throw new Error('CSI indexes do not support indexcov');\n    }\n    parseAuxData(bytes, offset) {\n        const dataView = new DataView(bytes.buffer);\n        const formatFlags = dataView.getInt32(offset, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = formats[(formatFlags & 0xF)];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(offset + 4, true),\n            start: dataView.getInt32(offset + 8, true),\n            end: dataView.getInt32(offset + 12, true),\n        };\n        const metaValue = dataView.getInt32(offset + 16, true);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : undefined;\n        const skipLines = dataView.getInt32(offset + 20, true);\n        const nameSectionLength = dataView.getInt32(offset + 24, true);\n        const { refIdToName, refNameToId } = this._parseNameBytes(bytes.subarray(offset + 28, offset + 28 + nameSectionLength));\n        return {\n            refIdToName,\n            refNameToId,\n            skipLines,\n            metaChar,\n            columnNumbers,\n            format,\n            coordinateType,\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return {\n            refNameToId,\n            refIdToName,\n        };\n    }\n    async _parse(opts = {}) {\n        const bytes = await unzip(await this.filehandle.readFile(opts));\n        const dataView = new DataView(bytes.buffer);\n        // check TBI magic numbers\n        let csiVersion;\n        if (dataView.getUint32(0, true) === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (dataView.getUint32(0, true) === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error('Not a CSI file');\n        }\n        this.minShift = dataView.getInt32(4, true);\n        this.depth = dataView.getInt32(8, true);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (this.minShift + this.depth * 3);\n        const auxLength = dataView.getInt32(12, true);\n        const aux = auxLength && auxLength >= 30\n            ? this.parseAuxData(bytes, 16)\n            : {\n                refIdToName: [],\n                refNameToId: {},\n                metaChar: undefined,\n                columnNumbers: { ref: 0, start: 1, end: 2 },\n                coordinateType: 'zero-based-half-open',\n                format: 'generic',\n            };\n        const refCount = dataView.getInt32(16 + auxLength, true);\n        // read the indexes for each reference sequence\n        let firstDataLine;\n        let currOffset = 16 + auxLength + 4;\n        const indices = new Array(refCount).fill(0).map(() => {\n            const binCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(currOffset, true);\n                if (bin > this.maxBinNumber) {\n                    // this is a fake bin that actually has stats information about the\n                    // reference sequence in it\n                    stats = this.parsePseudoBin(bytes, currOffset + 4);\n                    currOffset += 4 + 8 + 4 + 16 + 16;\n                }\n                else {\n                    const loffset = fromBytes(bytes, currOffset + 4);\n                    firstDataLine = this._findFirstData(firstDataLine, loffset);\n                    const chunkCount = dataView.getInt32(currOffset + 12, true);\n                    currOffset += 16;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, currOffset);\n                        const v = fromBytes(bytes, currOffset + 8);\n                        currOffset += 16;\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            return { binIndex, stats };\n        });\n        return {\n            ...aux,\n            csi: true,\n            refCount,\n            maxBlockSize: 1 << 16,\n            firstDataLine,\n            csiVersion,\n            indices,\n            depth: this.depth,\n            maxBinNumber: this.maxBinNumber,\n            maxRefLength,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        return {\n            lineCount: longFromBytesToUnsigned(bytes, offset + 28),\n        };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        // List of bin #s that overlap min, max\n        const overlappingBins = this.reg2bins(min, max);\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    for (const c of ba.binIndex[bin]) {\n                        chunks.push(new Chunk(c.minv, c.maxv, bin));\n                    }\n                }\n            }\n        }\n        return optimizeChunks(chunks, new VirtualOffset(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n}\n//# sourceMappingURL=csi.js.map","import { unzip } from '@gmod/bgzf-filehandle';\nimport Chunk from \"./chunk.js\";\nimport IndexFile from \"./indexFile.js\";\nimport { longFromBytesToUnsigned } from \"./long.js\";\nimport { checkAbortSignal, optimizeChunks } from \"./util.js\";\nimport VirtualOffset, { fromBytes } from \"./virtualOffset.js\";\nconst TBI_MAGIC = 21578324; // TBI\\1\nconst TAD_LIDX_SHIFT = 14;\n/**\n * calculate the list of bins that may overlap with region [beg,end)\n * (zero-based half-open)\n */\nfunction reg2bins(beg, end) {\n    beg += 1; // < convert to 1-based closed\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nexport default class TabixIndex extends IndexFile {\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return -1;\n        }\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        return indexData.indices[refId].stats?.lineCount ?? -1;\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const buf = await this.filehandle.readFile(opts);\n        const bytes = await unzip(buf);\n        checkAbortSignal(opts.signal);\n        const dataView = new DataView(bytes.buffer);\n        const magic = dataView.getUint32(0, true);\n        if (magic !== TBI_MAGIC /* \"TBI\\1\" */) {\n            throw new Error('Not a TBI file');\n        }\n        // number of reference sequences in the index\n        const refCount = dataView.getUint32(4, true);\n        const formatFlags = dataView.getUint32(8, true);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const formatOpts = {\n            0: 'generic',\n            1: 'SAM',\n            2: 'VCF',\n        };\n        const format = formatOpts[formatFlags & 0xF];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: dataView.getInt32(12, true),\n            start: dataView.getInt32(16, true),\n            end: dataView.getInt32(20, true),\n        };\n        const metaValue = dataView.getInt32(24, true);\n        const depth = 5;\n        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (14 + depth * 3);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : undefined;\n        const skipLines = dataView.getInt32(28, true);\n        // read sequence dictionary\n        const nameSectionLength = dataView.getInt32(32, true);\n        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));\n        // read the indexes for each reference sequence\n        let currOffset = 36 + nameSectionLength;\n        let firstDataLine;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = dataView.getUint32(currOffset, true);\n                currOffset += 4;\n                if (bin > maxBinNumber + 1) {\n                    throw new Error('tabix index contains too many bins, please use a CSI index');\n                }\n                else if (bin === maxBinNumber + 1) {\n                    const chunkCount = dataView.getInt32(currOffset, true);\n                    currOffset += 4;\n                    if (chunkCount === 2) {\n                        stats = this.parsePseudoBin(bytes, currOffset);\n                    }\n                    currOffset += 16 * chunkCount;\n                }\n                else {\n                    const chunkCount = dataView.getInt32(currOffset, true);\n                    currOffset += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = fromBytes(bytes, currOffset);\n                        const v = fromBytes(bytes, currOffset + 8);\n                        currOffset += 16;\n                        firstDataLine = this._findFirstData(firstDataLine, u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            // the linear index\n            const linearCount = dataView.getInt32(currOffset, true);\n            currOffset += 4;\n            const linearIndex = new Array(linearCount);\n            for (let k = 0; k < linearCount; k += 1) {\n                linearIndex[k] = fromBytes(bytes, currOffset);\n                currOffset += 8;\n                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);\n            }\n            return {\n                binIndex,\n                linearIndex,\n                stats,\n            };\n        });\n        return {\n            indices,\n            metaChar,\n            maxBinNumber,\n            maxRefLength,\n            skipLines,\n            firstDataLine,\n            columnNumbers,\n            coordinateType,\n            format,\n            refIdToName,\n            refNameToId,\n            maxBlockSize: 1 << 16,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        return {\n            lineCount: longFromBytesToUnsigned(bytes, offset + 16),\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        const decoder = new TextDecoder('utf8');\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    const refName = this.renameRefSeq(decoder.decode(namesBytes.subarray(currNameStart, i)));\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return {\n            refNameToId,\n            refIdToName,\n        };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        const refId = indexData.refNameToId[refName];\n        if (refId === undefined) {\n            return [];\n        }\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        const minOffset = ba.linearIndex.length > 0\n            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length\n                ? ba.linearIndex.length - 1\n                : min >> TAD_LIDX_SHIFT]\n            : new VirtualOffset(0, 0);\n        if (!minOffset) {\n            console.warn('querying outside of possible tabix range');\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    for (const c of ba.binIndex[bin]) {\n                        chunks.push(new Chunk(c.minv, c.maxv, bin));\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n                lowest = vp;\n            }\n        }\n        return optimizeChunks(chunks, lowest);\n    }\n}\n//# sourceMappingURL=tbi.js.map","import AbortablePromiseCache from '@gmod/abortable-promise-cache';\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle';\nimport { LocalFile, RemoteFile } from 'generic-filehandle2';\nimport LRU from 'quick-lru';\nimport CSI from \"./csi.js\";\nimport TBI from \"./tbi.js\";\nimport { checkAbortSignal } from \"./util.js\";\nfunction isASCII(str) {\n    // eslint-disable-next-line no-control-regex\n    return /^[\\u0000-\\u007F]*$/.test(str);\n}\nexport default class TabixIndexedFile {\n    /**\n     * @param {object} args\n     *\n     * @param {string} [args.path]\n     *\n     * @param {filehandle} [args.filehandle]\n     *\n     * @param {string} [args.tbiPath]\n     *\n     * @param {filehandle} [args.tbiFilehandle]\n     *\n     * @param {string} [args.csiPath]\n     *\n     * @param {filehandle} [args.csiFilehandle]\n     *\n     * @param {url} [args.url]\n     *\n     * @param {csiUrl} [args.csiUrl]\n     *\n     * @param {tbiUrl} [args.tbiUrl]\n     *\n     * @param {function} [args.renameRefSeqs] optional function with sig `string\n     * => string` to transform reference sequence names for the purpose of\n     * indexing and querying. note that the data that is returned is not altered,\n     * just the names of the reference sequences that are used for querying.\n     */\n    constructor({ path, filehandle, url, tbiPath, tbiUrl, tbiFilehandle, csiPath, csiUrl, csiFilehandle, renameRefSeqs = n => n, chunkCacheSize = 5 * 2 ** 20, }) {\n        this.cache = new LRU({\n            maxSize: 1000,\n        });\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new LocalFile(path);\n        }\n        else if (url) {\n            this.filehandle = new RemoteFile(url);\n        }\n        else {\n            throw new TypeError('must provide either filehandle or path');\n        }\n        if (tbiFilehandle) {\n            this.index = new TBI({\n                filehandle: tbiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (csiFilehandle) {\n            this.index = new CSI({\n                filehandle: csiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (tbiPath) {\n            this.index = new TBI({\n                filehandle: new LocalFile(tbiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (csiPath) {\n            this.index = new CSI({\n                filehandle: new LocalFile(csiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (path) {\n            this.index = new TBI({\n                filehandle: new LocalFile(`${path}.tbi`),\n                renameRefSeqs,\n            });\n        }\n        else if (csiUrl) {\n            this.index = new CSI({\n                filehandle: new RemoteFile(csiUrl),\n            });\n        }\n        else if (tbiUrl) {\n            this.index = new TBI({\n                filehandle: new RemoteFile(tbiUrl),\n            });\n        }\n        else if (url) {\n            this.index = new TBI({\n                filehandle: new RemoteFile(`${url}.tbi`),\n            });\n        }\n        else {\n            throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl');\n        }\n        this.renameRefSeq = renameRefSeqs;\n        this.chunkCache = new AbortablePromiseCache({\n            cache: new LRU({ maxSize: Math.floor(chunkCacheSize / (1 << 16)) }),\n            fill: (args, signal) => this.readChunk(args, { signal }),\n        });\n    }\n    /**\n     * @param refName name of the reference sequence\n     *\n     * @param start start of the region (in 0-based half-open coordinates)\n     *\n     * @param end end of the region (in 0-based half-open coordinates)\n     *\n     * @param opts callback called for each line in the region. can also pass a\n     * object param containing obj.lineCallback, obj.signal, etc\n     *\n     * @returns promise that is resolved when the whole read is finished,\n     * rejected on error\n     */\n    async getLines(refName, s, e, opts) {\n        let signal;\n        let options = {};\n        let callback;\n        if (typeof opts === 'function') {\n            callback = opts;\n        }\n        else {\n            options = opts;\n            callback = opts.lineCallback;\n            signal = opts.signal;\n        }\n        const metadata = await this.index.getMetadata(options);\n        checkAbortSignal(signal);\n        const start = s ?? 0;\n        const end = e ?? metadata.maxRefLength;\n        if (!(start <= end)) {\n            throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');\n        }\n        if (start === end) {\n            return;\n        }\n        const chunks = await this.index.blocksForRange(refName, start, end, options);\n        checkAbortSignal(signal);\n        const decoder = new TextDecoder('utf8');\n        // now go through each chunk and parse and filter the lines out of it\n        for (const c of chunks) {\n            const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c, signal);\n            checkAbortSignal(signal);\n            let blockStart = 0;\n            let pos = 0;\n            // fast path, Buffer is just ASCII chars and not gigantor, can be\n            // converted to string and processed directly. if it is not ASCII or\n            // gigantic (chrome max str len is 512Mb), we have to decode line by line\n            const str = decoder.decode(buffer);\n            const strIsASCII = isASCII(str);\n            while (blockStart < str.length) {\n                let line;\n                let n;\n                if (strIsASCII) {\n                    n = str.indexOf('\\n', blockStart);\n                    if (n === -1) {\n                        break;\n                    }\n                    line = str.slice(blockStart, n);\n                }\n                else {\n                    n = buffer.indexOf('\\n'.charCodeAt(0), blockStart);\n                    if (n === -1) {\n                        break;\n                    }\n                    const b = buffer.slice(blockStart, n);\n                    line = decoder.decode(b);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (dpositions) {\n                    while (blockStart + c.minv.dataPosition >= dpositions[pos++]) { }\n                    pos--;\n                }\n                // filter the line for whether it is within the requested range\n                const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);\n                if (overlaps) {\n                    callback(line, \n                    // cpositions[pos] refers to actual file offset of a bgzip block\n                    // boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a\n                    // \"unique\" address space so that data in that block could never\n                    // overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset\n                    // from that bgzip block boundary, and since the cpositions are\n                    // multiplied by (1 << 8) these uncompressed offsets get a unique\n                    // space\n                    cpositions[pos] * (1 << 8) +\n                        (blockStart - dpositions[pos]) +\n                        c.minv.dataPosition +\n                        1);\n                }\n                else if (startCoordinate !== undefined && startCoordinate >= end) {\n                    // the lines were overlapping the region, but now have stopped, so we\n                    // must be at the end of the relevant data and we can stop processing\n                    // data now\n                    return;\n                }\n                blockStart = n + 1;\n            }\n        }\n    }\n    async getMetadata(opts = {}) {\n        return this.index.getMetadata(opts);\n    }\n    /**\n     * get a buffer containing the \"header\" region of the file, which are the\n     * bytes up to the first non-meta line\n     */\n    async getHeaderBuffer(opts = {}) {\n        const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);\n        checkAbortSignal(opts.signal);\n        const maxFetch = (firstDataLine?.blockPosition || 0) + maxBlockSize;\n        // TODO: what if we don't have a firstDataLine, and the header actually\n        // takes up more than one block? this case is not covered here\n        const buf = await this.filehandle.read(maxFetch, 0, opts);\n        const bytes = await unzip(buf);\n        // trim off lines after the last non-meta line\n        if (metaChar) {\n            // trim backward from the end\n            let lastNewline = -1;\n            const newlineByte = '\\n'.charCodeAt(0);\n            const metaByte = metaChar.charCodeAt(0);\n            for (let i = 0, l = bytes.length; i < l; i++) {\n                const byte = bytes[i];\n                if (i === lastNewline + 1 && byte !== metaByte) {\n                    break;\n                }\n                if (byte === newlineByte) {\n                    lastNewline = i;\n                }\n            }\n            return bytes.subarray(0, lastNewline + 1);\n        }\n        return bytes;\n    }\n    /**\n     * get a string containing the \"header\" region of the file, is the portion up\n     * to the first non-meta line\n     *\n     * @returns {Promise} for a string\n     */\n    async getHeader(opts = {}) {\n        const decoder = new TextDecoder('utf8');\n        const bytes = await this.getHeaderBuffer(opts);\n        return decoder.decode(bytes);\n    }\n    /**\n     * get an array of reference sequence names, in the order in which they occur\n     * in the file. reference sequence renaming is not applied to these names.\n     */\n    async getReferenceSequenceNames(opts = {}) {\n        const metadata = await this.getMetadata(opts);\n        return metadata.refIdToName;\n    }\n    /**\n     * @param {object} metadata metadata object from the parsed index, containing\n     * columnNumbers, metaChar, and format\n     *\n     * @param {string} regionRefName\n     *\n     * @param {number} regionStart region start coordinate (0-based-half-open)\n     *\n     * @param {number} regionEnd region end coordinate (0-based-half-open)\n     *\n     * @param {array[string]} line\n     *\n     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,\n     * true if line is a data line that overlaps the given region\n     */\n    checkLine(metadata, regionRefName, regionStart, regionEnd, line) {\n        const { columnNumbers, metaChar, coordinateType, format } = metadata;\n        // skip meta lines\n        if (metaChar && line.startsWith(metaChar)) {\n            return { overlaps: false };\n        }\n        // check ref/start/end using column metadata from index\n        let { ref, start, end } = columnNumbers;\n        if (!ref) {\n            ref = 0;\n        }\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = 0;\n        }\n        if (format === 'VCF') {\n            end = 8;\n        }\n        const maxColumn = Math.max(ref, start, end);\n        // this code is kind of complex, but it is fairly fast. basically, we want\n        // to avoid doing a split, because if the lines are really long that could\n        // lead to us allocating a bunch of extra memory, which is slow\n        let currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata\n        let currentColumnStart = 0;\n        let refSeq = '';\n        let startCoordinate = -Infinity;\n        const l = line.length;\n        for (let i = 0; i < l + 1; i++) {\n            if (line[i] === '\\t' || i === l) {\n                if (currentColumnNumber === ref) {\n                    if (this.renameRefSeq(line.slice(currentColumnStart, i)) !==\n                        regionRefName) {\n                        return {\n                            overlaps: false,\n                        };\n                    }\n                }\n                else if (currentColumnNumber === start) {\n                    startCoordinate = Number.parseInt(line.slice(currentColumnStart, i), 10);\n                    // we convert to 0-based-half-open\n                    if (coordinateType === '1-based-closed') {\n                        startCoordinate -= 1;\n                    }\n                    if (startCoordinate >= regionEnd) {\n                        return {\n                            startCoordinate,\n                            overlaps: false,\n                        };\n                    }\n                    if ((end === 0 || end === start) && // if we have no end, we assume the feature is 1 bp long\n                        startCoordinate + 1 <= regionStart) {\n                        return {\n                            startCoordinate,\n                            overlaps: false,\n                        };\n                    }\n                }\n                else if (format === 'VCF' && currentColumnNumber === 4) {\n                    refSeq = line.slice(currentColumnStart, i);\n                }\n                else if (currentColumnNumber === end) {\n                    // this will never match if there is no end column\n                    const endCoordinate = format === 'VCF'\n                        ? this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i))\n                        : Number.parseInt(line.slice(currentColumnStart, i), 10);\n                    if (endCoordinate <= regionStart) {\n                        return {\n                            overlaps: false,\n                        };\n                    }\n                }\n                currentColumnStart = i + 1;\n                currentColumnNumber += 1;\n                if (currentColumnNumber > maxColumn) {\n                    break;\n                }\n            }\n        }\n        return {\n            startCoordinate,\n            overlaps: true,\n        };\n    }\n    _getVcfEnd(startCoordinate, refSeq, info) {\n        let endCoordinate = startCoordinate + refSeq.length;\n        // ignore TRA features as they specify CHR2 and END as being on a different\n        // chromosome\n        //\n        // if CHR2 is on the same chromosome, still ignore it because there should\n        // be another pairwise feature at the end of this one\n        const isTRA = info.includes('SVTYPE=TRA');\n        if (info[0] !== '.' && !isTRA) {\n            let prevChar = ';';\n            for (let j = 0; j < info.length; j += 1) {\n                if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {\n                    let valueEnd = info.indexOf(';', j);\n                    if (valueEnd === -1) {\n                        valueEnd = info.length;\n                    }\n                    endCoordinate = Number.parseInt(info.slice(j + 4, valueEnd), 10);\n                    break;\n                }\n                prevChar = info[j];\n            }\n        }\n        else if (isTRA) {\n            return startCoordinate + 1;\n        }\n        return endCoordinate;\n    }\n    /**\n     * return the approximate number of data lines in the given reference\n     * sequence\n     *\n     * @param refSeq reference sequence name\n     *\n     * @returns number of data lines present on that reference sequence\n     */\n    async lineCount(refName, opts = {}) {\n        return this.index.lineCount(refName, opts);\n    }\n    /**\n     * read and uncompress the data in a chunk (composed of one or more\n     * contiguous bgzip blocks) of the file\n     */\n    async readChunk(c, opts = {}) {\n        const ret = await this.filehandle.read(c.fetchedSize(), c.minv.blockPosition, opts);\n        return unzipChunkSlice(ret, c, this.cache);\n    }\n}\n//# sourceMappingURL=tabixIndexedFile.js.map"],"names":["Chunk","minv","maxv","bin","fetchedSize","b","IndexFile","filehandle","renameRefSeqs","opts","_indices","rest","currentFdl","virtualOffset","error","seqId","TWO_PWR_16_DBL","TWO_PWR_32_DBL","longFromBytesToUnsigned","source","i","low","AbortError","checkAbortSignal","signal","canMergeBlocks","chunk1","chunk2","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","c0","c1","dif","chunk","VirtualOffset","blockPosition","dataPosition","fromBytes","bytes","offset","CSI1_MAGIC","CSI2_MAGIC","formats","lshift","num","bits","rshift","CSI","args","refName","indexData","refId","stats","dataView","formatFlags","coordinateType","format","columnNumbers","metaValue","metaChar","skipLines","nameSectionLength","refIdToName","refNameToId","namesBytes","currRefId","currNameStart","decoder","unzip","csiVersion","maxRefLength","auxLength","aux","refCount","firstDataLine","currOffset","indices","binCount","binIndex","j","loffset","chunkCount","u","v","min","max","ba","overlappingBins","start","end","c","beg","l","t","s","bins","e","TBI_MAGIC","TAD_LIDX_SHIFT","reg2bins","TabixIndex","buf","depth","maxBinNumber","k","linearCount","linearIndex","nintv","minLin","maxLin","vp","isASCII","str","TabixIndexedFile","path","url","tbiPath","tbiUrl","tbiFilehandle","csiPath","csiUrl","csiFilehandle","n","chunkCacheSize","LRU","LocalFile","RemoteFile","TBI","AbortablePromiseCache","options","callback","metadata","buffer","cpositions","dpositions","blockStart","pos","strIsASCII","line","startCoordinate","overlaps","maxBlockSize","maxFetch","lastNewline","newlineByte","metaByte","byte","regionRefName","regionStart","regionEnd","ref","maxColumn","currentColumnNumber","currentColumnStart","refSeq","info","endCoordinate","isTRA","prevChar","valueEnd","ret","unzipChunkSlice"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}