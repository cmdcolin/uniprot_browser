{"version":3,"file":"SNPCoverageAdapter-CsL1fOxt.js","sources":["../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processDepth.js","../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/util.js","../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processMismatches.js","../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processModifications.js","../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/processReferenceCpGs.js","../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/generateCoverageBins.js","../../node_modules/@jbrowse/plugin-alignments/esm/SNPCoverageAdapter/SNPCoverageAdapter.js"],"sourcesContent":["export function processDepth({ feature, bins, region, }) {\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const regionLength = region.end - region.start;\n    for (let j = fstart; j < fend + 1; j++) {\n        const i = j - region.start;\n        if (i >= 0 && i < regionLength) {\n            if (bins[i] === undefined) {\n                bins[i] = {\n                    depth: 0,\n                    readsCounted: 0,\n                    ref: {\n                        probabilities: [],\n                        entryDepth: 0,\n                        '-1': 0,\n                        0: 0,\n                        1: 0,\n                    },\n                    snps: {},\n                    mods: {},\n                    nonmods: {},\n                    delskips: {},\n                    noncov: {},\n                };\n            }\n            if (j !== fend) {\n                bins[i].depth++;\n                bins[i].readsCounted++;\n                bins[i].ref.entryDepth++;\n                bins[i].ref[fstrand]++;\n            }\n        }\n    }\n}\n","export function mismatchLen(mismatch) {\n    return !isInterbase(mismatch.type) ? mismatch.length : 1;\n}\nexport function isInterbase(type) {\n    return type === 'softclip' || type === 'hardclip' || type === 'insertion';\n}\nexport function inc(bin, strand, type, field) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            entryDepth: 0,\n            probabilities: [],\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.entryDepth++;\n    thisBin[strand]++;\n}\nexport function incWithProbabilities(bin, strand, type, field, probability) {\n    let thisBin = bin[type][field];\n    if (thisBin === undefined) {\n        thisBin = bin[type][field] = {\n            entryDepth: 0,\n            probabilities: [],\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n        };\n    }\n    thisBin.entryDepth++;\n    thisBin.probabilities.push(probability);\n    thisBin[strand]++;\n}\n","import { inc, isInterbase, mismatchLen } from './util';\nexport function processMismatches({ feature, region, bins, skipmap, }) {\n    var _a;\n    const fstart = feature.get('start');\n    const fstrand = feature.get('strand');\n    const mismatches = (_a = feature.get('mismatches')) !== null && _a !== void 0 ? _a : [];\n    for (const mismatch of mismatches) {\n        const mstart = fstart + mismatch.start;\n        const mlen = mismatchLen(mismatch);\n        const mend = mstart + mlen;\n        for (let j = mstart; j < mstart + mlen; j++) {\n            const epos = j - region.start;\n            if (epos >= 0 && epos < bins.length) {\n                const bin = bins[epos];\n                const { base, altbase, type } = mismatch;\n                const interbase = isInterbase(type);\n                if (type === 'deletion' || type === 'skip') {\n                    inc(bin, fstrand, 'delskips', type);\n                    bin.depth--;\n                }\n                else if (!interbase) {\n                    inc(bin, fstrand, 'snps', base);\n                    bin.ref.entryDepth--;\n                    bin.ref[fstrand]--;\n                    bin.refbase = altbase;\n                }\n                else {\n                    inc(bin, fstrand, 'noncov', type);\n                }\n            }\n        }\n        if (mismatch.type === 'skip') {\n            const tags = feature.get('tags');\n            const xs = (tags === null || tags === void 0 ? void 0 : tags.XS) || (tags === null || tags === void 0 ? void 0 : tags.TS);\n            const ts = tags === null || tags === void 0 ? void 0 : tags.ts;\n            const effectiveStrand = xs === '+'\n                ? 1\n                : xs === '-'\n                    ? -1\n                    : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand;\n            const hash = `${mstart}_${mend}_${effectiveStrand}`;\n            if (skipmap[hash] === undefined) {\n                skipmap[hash] = {\n                    feature: feature,\n                    start: mstart,\n                    end: mend,\n                    strand: fstrand,\n                    effectiveStrand,\n                    score: 0,\n                };\n            }\n            skipmap[hash].score++;\n        }\n    }\n}\n","import { max, sum } from '@jbrowse/core/util';\nimport { incWithProbabilities } from './util';\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition';\nexport function processModifications({ feature, colorBy, region, bins, regionSequence, }) {\n    var _a, _b, _c;\n    const fstart = feature.get('start');\n    const fstrand = feature.get('strand');\n    const fend = feature.get('end');\n    const twoColor = (_a = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _a === void 0 ? void 0 : _a.twoColor;\n    const isolatedModification = (_b = colorBy === null || colorBy === void 0 ? void 0 : colorBy.modifications) === null || _b === void 0 ? void 0 : _b.isolatedModification;\n    (_c = getMaxProbModAtEachPosition(feature)) === null || _c === void 0 ? void 0 : _c.forEach(({ allProbs, prob, type }, pos) => {\n        if (isolatedModification && type !== isolatedModification) {\n            return;\n        }\n        const epos = pos + fstart - region.start;\n        if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n            if (bins[epos] === undefined) {\n                bins[epos] = {\n                    depth: 0,\n                    readsCounted: 0,\n                    snps: {},\n                    ref: {\n                        probabilities: [],\n                        entryDepth: 0,\n                        '-1': 0,\n                        0: 0,\n                        1: 0,\n                    },\n                    mods: {},\n                    nonmods: {},\n                    delskips: {},\n                    noncov: {},\n                };\n            }\n            const s = 1 - sum(allProbs);\n            const bin = bins[epos];\n            bin.refbase = regionSequence[epos];\n            if (twoColor && s > max(allProbs)) {\n                incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s);\n            }\n            else {\n                incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob);\n            }\n        }\n        pos++;\n    });\n}\n","import { doesIntersect2 } from '@jbrowse/core/util';\nimport { parseCigar } from '../MismatchParser';\nimport { incWithProbabilities } from './util';\nimport { getMethBins } from '../ModificationParser/getMethBins';\nexport function processReferenceCpGs({ feature, region, bins, regionSequence, }) {\n    var _a;\n    const fstart = feature.get('start');\n    const fend = feature.get('end');\n    const fstrand = feature.get('strand');\n    const seq = feature.get('seq');\n    const mismatches = (_a = feature.get('mismatches')) !== null && _a !== void 0 ? _a : [];\n    const r = regionSequence.toLowerCase();\n    if (seq) {\n        const cigarOps = parseCigar(feature.get('CIGAR'));\n        const { methBins, methProbs } = getMethBins(feature, cigarOps);\n        const dels = mismatches.filter(f => f.type === 'deletion');\n        for (let i = 0; i < fend - fstart; i++) {\n            const j = i + fstart;\n            const l1 = r[j - region.start + 1];\n            const l2 = r[j - region.start + 2];\n            if (l1 === 'c' && l2 === 'g') {\n                const bin0 = bins[j - region.start];\n                const bin1 = bins[j - region.start + 1];\n                const b0 = methBins[i];\n                const b1 = methBins[i + 1];\n                const p0 = methProbs[i];\n                const p1 = methProbs[i + 1];\n                if ((b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n                    (b1 && (p1 !== undefined ? p1 > 0.5 : true))) {\n                    if (bin0) {\n                        incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0);\n                        bin0.ref.entryDepth--;\n                        bin0.ref[fstrand]--;\n                    }\n                    if (bin1) {\n                        incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0);\n                        bin1.ref.entryDepth--;\n                        bin1.ref[fstrand]--;\n                    }\n                }\n                else {\n                    if (bin0) {\n                        if (!dels.some(d => doesIntersect2(j, j + 1, d.start + fstart, d.start + fstart + d.length))) {\n                            incWithProbabilities(bin0, fstrand, 'nonmods', 'cpg_unmeth', 1 - (p0 || 0));\n                            bin0.ref.entryDepth--;\n                            bin0.ref[fstrand]--;\n                        }\n                    }\n                    if (bin1) {\n                        if (!dels.some(d => doesIntersect2(j + 1, j + 2, d.start + fstart, d.start + fstart + d.length))) {\n                            incWithProbabilities(bin1, fstrand, 'nonmods', 'cpg_unmeth', 1 - (p1 || 0));\n                            bin1.ref.entryDepth--;\n                            bin1.ref[fstrand]--;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","import { sum } from '@jbrowse/core/util';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { processDepth } from './processDepth';\nimport { processMismatches } from './processMismatches';\nimport { processModifications } from './processModifications';\nimport { processReferenceCpGs } from './processReferenceCpGs';\nexport async function generateCoverageBins({ fetchSequence, features, region, opts, }) {\n    const { stopToken, colorBy } = opts;\n    const skipmap = {};\n    const bins = [];\n    const start2 = Math.max(0, region.start - 1);\n    const diff = region.start - start2;\n    let start = performance.now();\n    for (const feature of features) {\n        if (performance.now() - start > 400) {\n            checkStopToken(stopToken);\n            start = performance.now();\n        }\n        processDepth({\n            feature,\n            bins,\n            region,\n        });\n        if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {\n            const regionSequence = (await fetchSequence({\n                ...region,\n                start: start2,\n                end: region.end + 1,\n            })) || '';\n            processModifications({\n                feature,\n                colorBy,\n                bins,\n                region,\n                regionSequence: regionSequence.slice(diff),\n            });\n        }\n        else if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {\n            const regionSequence = (await fetchSequence({\n                ...region,\n                start: start2,\n                end: region.end + 1,\n            })) || '';\n            processReferenceCpGs({\n                feature,\n                bins,\n                region,\n                regionSequence,\n            });\n        }\n        processMismatches({ feature, skipmap, bins, region });\n    }\n    for (const bin of bins) {\n        if (bin) {\n            bin.mods = Object.fromEntries(Object.entries(bin.mods).map(([key, val]) => {\n                return [\n                    key,\n                    {\n                        ...val,\n                        avgProbability: val.probabilities.length\n                            ? sum(val.probabilities) / val.probabilities.length\n                            : undefined,\n                    },\n                ];\n            }));\n            bin.nonmods = Object.fromEntries(Object.entries(bin.nonmods).map(([key, val]) => {\n                return [\n                    key,\n                    {\n                        ...val,\n                        avgProbability: val.probabilities.length\n                            ? sum(val.probabilities) / val.probabilities.length\n                            : undefined,\n                    },\n                ];\n            }));\n        }\n    }\n    return {\n        bins,\n        skipmap,\n    };\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature';\nimport { firstValueFrom } from 'rxjs';\nimport { toArray } from 'rxjs/operators';\nimport { fetchSequence } from '../util';\nimport { generateCoverageBins } from './generateCoverageBins';\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n    async configure() {\n        var _a, _b;\n        const subadapterConfig = this.getConf('subadapter');\n        const sequenceConf = subadapterConfig.sequenceAdapter;\n        const dataAdapter = await ((_a = this.getSubAdapter) === null || _a === void 0 ? void 0 : _a.call(this, subadapterConfig));\n        const sequenceAdapter = sequenceConf\n            ? await ((_b = this.getSubAdapter) === null || _b === void 0 ? void 0 : _b.call(this, sequenceConf))\n            : undefined;\n        if (!dataAdapter) {\n            throw new Error('Failed to get subadapter');\n        }\n        return {\n            subadapter: dataAdapter.dataAdapter,\n            sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter,\n        };\n    }\n    async fetchSequence(region) {\n        const { sequenceAdapter } = await this.configure();\n        if (!sequenceAdapter) {\n            return undefined;\n        }\n        return fetchSequence(region, sequenceAdapter);\n    }\n    getFeatures(region, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            const { subadapter } = await this.configure();\n            const features = await firstValueFrom(subadapter.getFeatures(region, opts).pipe(toArray()));\n            const { bins, skipmap } = await generateCoverageBins({\n                features,\n                region,\n                opts,\n                fetchSequence: (region) => this.fetchSequence(region),\n            });\n            let index = 0;\n            for (const bin of bins) {\n                if (bin) {\n                    const start = region.start + index;\n                    observer.next(new SimpleFeature({\n                        id: `${this.id}-${start}`,\n                        data: {\n                            score: bin.depth,\n                            snpinfo: bin,\n                            start,\n                            end: start + 1,\n                            refName: region.refName,\n                        },\n                    }));\n                }\n                index++;\n            }\n            for (const [key, skip] of Object.entries(skipmap)) {\n                observer.next(new SimpleFeature({\n                    id: key,\n                    data: {\n                        type: 'skip',\n                        start: skip.start,\n                        end: skip.end,\n                        strand: skip.strand,\n                        score: skip.score,\n                        effectiveStrand: skip.effectiveStrand,\n                    },\n                }));\n            }\n            observer.complete();\n        }, opts.stopToken);\n    }\n    async getMultiRegionFeatureDensityStats(regions, opts) {\n        const { subadapter } = await this.configure();\n        return subadapter.getMultiRegionFeatureDensityStats(regions, opts);\n    }\n    async getRefNames(opts = {}) {\n        const { subadapter } = await this.configure();\n        return subadapter.getRefNames(opts);\n    }\n}\n"],"names":["processDepth","feature","bins","region","fstart","fend","fstrand","regionLength","j","i","mismatchLen","mismatch","isInterbase","type","inc","bin","strand","field","thisBin","incWithProbabilities","probability","processMismatches","skipmap","_a","mismatches","mstart","mlen","mend","epos","base","altbase","interbase","tags","xs","ts","effectiveStrand","hash","processModifications","colorBy","regionSequence","_b","_c","twoColor","isolatedModification","getMaxProbModAtEachPosition","allProbs","prob","pos","s","sum","max","processReferenceCpGs","seq","r","cigarOps","parseCigar","methBins","methProbs","getMethBins","dels","f","l1","l2","bin0","bin1","b0","b1","p0","p1","d","doesIntersect2","generateCoverageBins","fetchSequence","features","opts","stopToken","start2","diff","start","checkStopToken","key","val","SNPCoverageAdapter","BaseFeatureDataAdapter","subadapterConfig","sequenceConf","dataAdapter","sequenceAdapter","ObservableCreate","observer","subadapter","firstValueFrom","toArray","index","SimpleFeature","skip","regions"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}