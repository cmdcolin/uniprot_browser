import{u as E,ag as L,y as P,av as F,a5 as v}from"./index-DPMJgfAS.js";import{B}from"./index-D3TbvS_u.js";import{p as I}from"./parseLineByLine-Cz_4ZyEp.js";import{r as O}from"./rxjs-DiVqhxS9.js";import{S as j}from"./index-usVTM9_X.js";import{z as k,a as R,f as $,s as z}from"./util-66Cgxenk.js";function D(c){const t={};for(const e of c){const s=e.qname,i=e.tname,m=`${s}-${i}`;t[m]||(t[m]={quals:[],len:[]}),t[m].quals.push(e.extra.mappingQual||1),t[m].len.push(e.extra.blockLen||1)}const a=Object.fromEntries(Object.entries(t).map(([e,s])=>{const i=k(s.quals,s.len);return[e,Q(i)]}));for(const e of c){const s=e.qname,i=e.tname,m=`${s}-${i}`;e.extra.meanScore=a[m]}let n=1e4,o=0;for(const e of c)n=Math.min(e.extra.meanScore||0,n),o=Math.max(e.extra.meanScore||0,o);for(const e of c){const s=e.extra.meanScore||0;e.extra.meanScore=(s-n)/(o-n)}return c}function Q(c){const[t,a]=c.reduce(([n,o],[e,s])=>[n+e*s,o+s],[0,0]);return t/a}const{parseCigar:U}=v;class G extends B.BaseFeatureDataAdapter{async setup(t){return this.setupP||(this.setupP=this.setupPre(t).catch(a=>{throw this.setupP=void 0,a})),this.setupP}async setupPre(t){const a=[];return I.parseLineByLine(await E.fetchAndMaybeUnzip(L.openLocation(this.getConf("pafLocation"),this.pluginManager),t),n=>(a.push(R(n)),!0),t?.statusCallback),a}async hasDataForRefName(){return!0}getAssemblyNames(){const t=this.getConf("assemblyNames");if(t.length===0){const a=this.getConf("queryAssembly"),n=this.getConf("targetAssembly");return[a,n]}return t}async getRefNames(t={}){var a;const n=(a=t.regions)===null||a===void 0?void 0:a[0].assemblyName,o=await this.setup(t),e=this.getAssemblyNames().indexOf(n);if(e!==-1){const s=new Set;for(const i of o)s.add(e===0?i.qname:i.tname);return[...s]}return console.warn("Unable to do ref renaming on adapter"),[]}getFeatures(t,a={}){return O.ObservableCreate(async n=>{let o=await this.setup(a);const{config:e}=a;e&&P.readConfObject(e,"colorBy")==="meanQueryIdentity"&&(o=D(o));const s=this.getAssemblyNames(),{start:i,end:m,refName:w,assemblyName:u}=t,N=s.indexOf(u),p=N===0;N===-1&&(console.warn(`${u} not found in this adapter`),n.complete());for(let f=0;f<o.length;f++){const r=o[f];let d=0,y=0,g="",h="",x=0,b=0;p?(d=r.qstart,y=r.qend,g=r.qname,h=r.tname,x=r.tstart,b=r.tend):(d=r.tstart,y=r.tend,g=r.tname,h=r.qname,x=r.qstart,b=r.qend);const{extra:l,strand:A}=r;if(g===w&&F.doesIntersect2(i,m,d,y)){const{numMatches:S=0,blockLen:C=1,cg:W,...M}=l;let q=l.cg;l.cg&&(p&&A===-1?q=$(U(l.cg)).join(""):p&&(q=z(l.cg))),n.next(new j({uniqueId:f+u,assemblyName:u,start:d,end:y,type:"match",refName:g,strand:A,...M,CIGAR:q,syntenyId:f,identity:S/C,numMatches:S,blockLen:C,mate:{start:x,end:b,refName:h,assemblyName:s[+p]}}))}}n.complete()})}}G.capabilities=["getFeatures","getRefNames"];export{G as default};
//# sourceMappingURL=PAFAdapter-nBgCWaS3.js.map
