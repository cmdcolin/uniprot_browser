import{I as D}from"./main-G3gN6lip.js";import{B as x}from"./index-D3TbvS_u.js";import{u as T,ag as A}from"./index-DPMJgfAS.js";import{r as $}from"./rxjs-DiVqhxS9.js";const j=new Set(["DUP","TRA","INV","CNV","DEL"]);function v(u,e,s,n){const t=u.split("	"),a=t[s?3:0],l=+t[s?4:1],o=+t[s?5:2],i=t[s?0:3],f=+t[s?1:4],c=+t[s?2:5],h=t[6],r=+t[7],d=g(t[8]),b=g(t[9]),p=t.slice(10),w=n?Object.fromEntries(n.slice(10).map((y,F)=>[y,p[F]])):{},m=j.has(p[0])?`<${p[0]}>`:void 0;return new T.SimpleFeature({...w,start:l,end:o,type:"paired_feature",refName:a,strand:d,name:h,score:r,uniqueId:e,mate:{refName:i,start:f,end:c,strand:b},...m?{ALT:[m]}:{}})}function g(u){return u==="+"?1:u==="-"?-1:u==="."?0:void 0}class E extends x.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(e){const n=(await T.fetchAndMaybeUnzipText(A.openLocation(this.getConf("bedpeLocation"),this.pluginManager),e)).split(/\n|\r\n|\r/).filter(c=>!!c),t=[];let a=0;for(;a<n.length&&n[a].startsWith("#");a++)t.push(n[a]);const l=t.join(`
`),o={},i={};for(;a<n.length;a++){const c=n[a],h=c.split("	"),r=h[0],d=h[3];o[r]||(o[r]=[]),i[d]||(i[d]=[]),o[r].push(c),i[d].push(c)}const f=this.getConf("columnNames");return{header:l,feats1:o,feats2:i,columnNames:f}}async loadData(e={}){return this.bedpeFeatures||(this.bedpeFeatures=this.loadDataP(e).catch(s=>{throw this.bedpeFeatures=void 0,s})),this.bedpeFeatures}async getRefNames(e={}){const{feats1:s,feats2:n}=await this.loadData(e);return[...new Set([...Object.keys(s),...Object.keys(n)])]}async getHeader(e={}){const{header:s}=await this.loadData(e);return s}async getNames(){const{header:e,columnNames:s}=await this.loadData();if(s.length)return s;const t=e.split(/\n|\r\n|\r/).filter(a=>!!a).at(-1);return t?.includes("	")?t.slice(1).split("	").map(a=>a.trim()):void 0}async loadFeatureTreeP(e){var s,n,t,a;const{feats1:l,feats2:o}=await this.loadData(),i=await this.getNames(),f=new D,c=(n=(s=l[e])===null||s===void 0?void 0:s.map((r,d)=>v(r,`${this.id}-${e}-${d}-r1`,!1,i)))!==null&&n!==void 0?n:[],h=(a=(t=o[e])===null||t===void 0?void 0:t.map((r,d)=>v(r,`${this.id}-${e}-${d}-r2`,!0,i)))!==null&&a!==void 0?a:[];for(const r of[...c,...h])f.insert([r.get("start"),r.get("end")],r);return f}async loadFeatureTree(e){return this.intervalTrees[e]||(this.intervalTrees[e]=this.loadFeatureTreeP(e).catch(s=>{throw this.intervalTrees[e]=void 0,s})),this.intervalTrees[e]}getFeatures(e,s={}){return $.ObservableCreate(async n=>{const{start:t,end:a,refName:l}=e,o=await this.loadFeatureTree(l);for(const i of o?.search([t,a])||[])n.next(i);n.complete()},s.stopToken)}}E.capabilities=["getFeatures","getRefNames"];export{E as default};
//# sourceMappingURL=BedpeAdapter-DL1Vjep7.js.map
