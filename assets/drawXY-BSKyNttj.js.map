{"version":3,"file":"drawXY-BSKyNttj.js","sources":["../../node_modules/@jbrowse/plugin-wiggle/esm/drawXY.js"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration';\nimport { clamp, featureSpanPx } from '@jbrowse/core/util';\nimport { colord } from '@jbrowse/core/util/colord';\nimport { checkStopToken } from '@jbrowse/core/util/stopToken';\nimport { fillRectCtx, getOrigin, getScale } from './util';\nfunction lighten(color, amount) {\n    const hslColor = color.toHsl();\n    const l = hslColor.l * (1 + amount);\n    return colord({\n        ...hslColor,\n        l: clamp(l, 0, 100),\n    });\n}\nfunction darken(color, amount) {\n    const hslColor = color.toHsl();\n    const l = hslColor.l * (1 - amount);\n    return colord({\n        ...hslColor,\n        l: clamp(l, 0, 100),\n    });\n}\nconst fudgeFactor = 0.3;\nconst clipHeight = 2;\nexport function drawXY(ctx, props) {\n    const { features, bpPerPx, regions, scaleOpts, height: unadjustedHeight, config, ticks, displayCrossHatches, offset = 0, colorCallback, inverted, stopToken, } = props;\n    const region = regions[0];\n    const width = (region.end - region.start) / bpPerPx;\n    const height = unadjustedHeight - offset * 2;\n    const filled = readConfObject(config, 'filled');\n    const clipColor = readConfObject(config, 'clipColor');\n    const summaryScoreMode = readConfObject(config, 'summaryScoreMode');\n    const pivotValue = readConfObject(config, 'bicolorPivotValue');\n    const minSize = readConfObject(config, 'minSize');\n    const scale = getScale({ ...scaleOpts, range: [0, height], inverted });\n    const originY = getOrigin(scaleOpts.scaleType);\n    const domain = scale.domain();\n    const niceMin = domain[0];\n    const niceMax = domain[1];\n    const toY = (n) => clamp(height - (scale(n) || 0), 0, height) + offset;\n    const toOrigin = (n) => toY(originY) - toY(n);\n    const getHeight = (n) => (filled ? toOrigin(n) : Math.max(minSize, 1));\n    let hasClipping = false;\n    let prevLeftPx = Number.NEGATIVE_INFINITY;\n    const reducedFeatures = [];\n    const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue;\n    let start = performance.now();\n    if (summaryScoreMode === 'whiskers') {\n        let lastCol;\n        let lastMix;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken(stopToken);\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            if (feature.get('summary')) {\n                const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n                const max = feature.get('maxScore');\n                const c = colorCallback(feature, max);\n                const effectiveC = crossingOrigin\n                    ? c\n                    : c === lastCol\n                        ? lastMix\n                        : (lastMix = lighten(colord(c), 0.4).toHex());\n                fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC);\n                lastCol = c;\n            }\n        }\n        lastMix = undefined;\n        lastCol = undefined;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken(stopToken);\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            const score = feature.get('score');\n            const max = feature.get('maxScore');\n            const min = feature.get('minScore');\n            const summary = feature.get('summary');\n            const c = colorCallback(feature, score);\n            const effectiveC = crossingOrigin && summary\n                ? c === lastCol\n                    ? lastMix\n                    : (lastMix = colord(colorCallback(feature, max))\n                        .mix(colord(colorCallback(feature, min)))\n                        .toString())\n                : c;\n            const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n            if (Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n                rightPx - leftPx > 1) {\n                reducedFeatures.push(feature);\n                prevLeftPx = leftPx;\n            }\n            hasClipping = hasClipping || score < niceMin || score > niceMax;\n            fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC);\n            lastCol = c;\n        }\n        lastMix = undefined;\n        lastCol = undefined;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken(stopToken);\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            if (feature.get('summary')) {\n                const min = feature.get('minScore');\n                const c = colorCallback(feature, min);\n                const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n                const effectiveC = crossingOrigin\n                    ? c\n                    : c === lastCol\n                        ? lastMix\n                        : (lastMix = darken(colord(c), 0.4).toHex());\n                fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC);\n                lastCol = c;\n            }\n        }\n    }\n    else {\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken(stopToken);\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            if (Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n                rightPx - leftPx > 1) {\n                reducedFeatures.push(feature);\n                prevLeftPx = leftPx;\n            }\n            const score = feature.get('score');\n            const c = colorCallback(feature, score);\n            hasClipping = hasClipping || score < niceMin || score > niceMax;\n            const w = Math.max(rightPx - leftPx + fudgeFactor, minSize);\n            if (summaryScoreMode === 'max') {\n                const s = feature.get('summary') ? feature.get('maxScore') : score;\n                fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c);\n            }\n            else if (summaryScoreMode === 'min') {\n                const s = feature.get('summary') ? feature.get('minScore') : score;\n                fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c);\n            }\n            else {\n                fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c);\n            }\n        }\n    }\n    ctx.save();\n    if (hasClipping) {\n        ctx.fillStyle = clipColor;\n        start = performance.now();\n        for (const feature of features.values()) {\n            if (performance.now() - start > 400) {\n                checkStopToken(stopToken);\n                start = performance.now();\n            }\n            const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx);\n            const w = rightPx - leftPx + fudgeFactor;\n            const score = feature.get('score');\n            if (score > niceMax) {\n                fillRectCtx(leftPx, offset, w, clipHeight, ctx);\n            }\n            else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n                fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx);\n            }\n        }\n    }\n    ctx.restore();\n    if (displayCrossHatches) {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'rgba(200,200,200,0.5)';\n        for (const tick of ticks.values) {\n            ctx.beginPath();\n            ctx.moveTo(0, Math.round(toY(tick)));\n            ctx.lineTo(width, Math.round(toY(tick)));\n            ctx.stroke();\n        }\n    }\n    return {\n        reducedFeatures,\n    };\n}\n"],"names":["lighten","color","amount","hslColor","colord","clamp","darken","fudgeFactor","clipHeight","drawXY","ctx","props","features","bpPerPx","regions","scaleOpts","unadjustedHeight","config","ticks","displayCrossHatches","offset","colorCallback","inverted","stopToken","region","width","height","filled","readConfObject","clipColor","summaryScoreMode","pivotValue","minSize","scale","getScale","originY","getOrigin","domain","niceMin","niceMax","toY","n","toOrigin","getHeight","hasClipping","prevLeftPx","reducedFeatures","crossingOrigin","start","lastCol","lastMix","feature","checkStopToken","leftPx","rightPx","featureSpanPx","w","max","c","effectiveC","fillRectCtx","score","min","summary","tick"],"mappings":"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","x_google_ignoreList":[0]}