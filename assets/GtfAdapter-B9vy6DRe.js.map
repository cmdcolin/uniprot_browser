{"version":3,"file":"GtfAdapter-B9vy6DRe.js","sources":["../../node_modules/gtf-nostream/esm/util.js","../../node_modules/gtf-nostream/esm/parse.js","../../node_modules/gtf-nostream/esm/api.js","../../node_modules/@jbrowse/plugin-gtf/esm/util.js","../../node_modules/@jbrowse/plugin-gtf/esm/GtfAdapter/GtfAdapter.js"],"sourcesContent":["//@ts-nocheck\n/** @module util */\n// Forks @gmod/gff-js and adapts it to parse and format GTF.\nconst fieldNames = [\n    'seq_name',\n    'source',\n    'featureType',\n    'start',\n    'end',\n    'score',\n    'strand',\n    'frame',\n    'attributes',\n];\n// TODO: check about enconding/escaping in gtf 9th column\n/**\n * Unescape a string/text value used in a GTF attribute.\n * Textual attributes should be surrounded by double quotes\n * source info:\n * https://mblab.wustl.edu/GTF22.html\n * https://en.wikipedia.org/wiki/Gene_transfer_format\n *\n * @param {String} s\n * @returns {String}\n */\nexport function unescape(s) {\n    if (s === null) {\n        return null;\n    }\n    return String(s).replace(/%([0-9A-Fa-f]{2})/g, (_, seq) => String.fromCharCode(parseInt(seq, 16)));\n}\n/**\n * Escape a value for use in a GTF attribute value.\n *\n * @param {String} s\n * @returns {String}\n */\nfunction _escape(regex, s) {\n    return String(s).replace(regex, ch => {\n        let hex = ch.charCodeAt(0).toString(16).toUpperCase();\n        // lol, apparently there's no native function for fixed-width hex output\n        if (hex.length < 2) {\n            hex = `0${hex}`;\n        }\n        return `%${hex}`;\n    });\n}\nexport function escape(s) {\n    // eslint-disable-next-line no-control-regex\n    return _escape(/[\\n;\\r\\t=%&,\\x00-\\x1f\\x7f-\\xff]/g, s);\n}\n/**\n * Escape a value for use in a GTF column value.\n *\n * @param {String} s\n * @returns {String}\n */\nexport function escapeColumn(s) {\n    // eslint-disable-next-line no-control-regex\n    return _escape(/[\\n\\r\\t%\\x00-\\x1f\\x7f-\\xff]/g, s);\n}\n/**\n * Parse the 9th column (attributes) of a GTF feature line.\n *\n * @param {String} attrString\n * @returns {Object}\n */\nexport function parseAttributes(attrString) {\n    if (!(attrString && attrString.length) || attrString === '.') {\n        return {};\n    }\n    const attrs = {};\n    attrString\n        .replace(/\\r?\\n$/, '')\n        .slice(0, -1) // need to remove the last semicolon in the attributes\n        .split(';')\n        .forEach(attribute => {\n        if (!attribute) {\n            return;\n        }\n        const attr = attribute.trim().split(' ');\n        if (!(attr[1] && attr[1].length)) {\n            return;\n        }\n        attr[0] = attr[0].trim();\n        let arec = attrs[attr[0].trim()];\n        if (!arec) {\n            arec = [];\n            attrs[attr[0]] = arec;\n        }\n        // arec.push(unescape(attr[1].trim()))\n        arec.push(...attr[1]\n            .split(',')\n            .map(s => s.trim())\n            .map(unescape));\n    });\n    return attrs;\n}\n/**\n * Parse a GTF feature line.\n *\n * @param {String} line\n * returns the parsed line in an object\n */\nexport function parseFeature(line) {\n    // assumed that there are no comments at the end of a line\n    // split the line into columns and replace '.' with null in each column\n    const f = line.split('\\t').map(a => (a === '.' ? null : a));\n    // unescape only the seq_name, source, and feature columns\n    f[0] = unescape(f[0]);\n    f[1] = unescape(f[1]);\n    f[2] = unescape(f[2]);\n    f[8] = parseAttributes(f[8]);\n    const parsed = {};\n    for (let i = 0; i < fieldNames.length; i += 1) {\n        parsed[fieldNames[i]] = f[i] === '.' ? null : f[i];\n    }\n    if (parsed.start !== null) {\n        parsed.start = parseInt(parsed.start, 10);\n    }\n    if (parsed.end !== null) {\n        parsed.end = parseInt(parsed.end, 10);\n    }\n    if (parsed.score !== null) {\n        parsed.score = parseFloat(parsed.score, 10);\n    }\n    if (parsed.strand != null) {\n        parsed.strand = parsed.strand;\n    }\n    return parsed;\n}\n/**\n * Parse a GTF directive/comment line.\n *\n * @param {String} line\n * @returns {Object} the information in the directive\n */\nexport function parseDirective(line) {\n    const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line);\n    // const match = /^\\s*\\#\\#\\s*(\\S+)\\s*(.*)/.exec(line)\n    if (!match) {\n        return null;\n    }\n    // let [, name, contents] = match\n    const name = match[1];\n    let contents = match[2];\n    const parsed = { directive: name };\n    if (contents.length) {\n        contents = contents.replace(/\\r?\\n$/, '');\n        parsed.value = contents;\n    }\n    // do a little additional parsing for sequence-region and genome-build directives\n    if (name === 'sequence-region') {\n        const [seqId, contentStart, contentEnd] = contents.split(/\\s+/, 3);\n        parsed.seq_id = seqId;\n        parsed.start = contentStart && contentStart.replace(/\\D/g, '');\n        parsed.end = contentEnd && contentEnd.replace(/\\D/g, '');\n    }\n    else if (name === 'genome-build') {\n        const [source, buildname] = contents.split(/\\s+/, 2);\n        parsed.source = source;\n        parsed.buildname = buildname;\n    }\n    return parsed;\n}\n/**\n * Format an attributes object into a string suitable for the 9th column of GTF.\n *\n * @param {Object} attrs\n */\nexport function formatAttributes(attrs) {\n    const attrOrder = [];\n    Object.keys(attrs).forEach(tag => {\n        const val = attrs[tag];\n        let valstring;\n        // eslint-disable-next-line no-prototype-builtins\n        if (val.hasOwnProperty('toString')) {\n            valstring = escape(val.toString());\n        }\n        else if (Array.isArray(val.values)) {\n            valstring = val.values.map(escape).join(',');\n        }\n        else if (Array.isArray(val)) {\n            valstring = val.map(escape).join(',');\n        }\n        else {\n            valstring = escape(val);\n        }\n        attrOrder.push(`${escape(tag)} ${valstring}`);\n    });\n    return attrOrder.length ? attrOrder.join('; ').concat(';') : '.';\n}\nconst translateStrand = ['-', '.', '+'];\nfunction _formatSingleFeature(f, seenFeature) {\n    const attrString = f.attributes === null || f.attributes === undefined\n        ? '.'\n        : formatAttributes(f.attributes);\n    const fields = [];\n    for (let i = 0; i < 8; i += 1) {\n        const val = f[fieldNames[i]];\n        // deserialize strand\n        if (i === 6) {\n            fields[i] =\n                val === null || val === undefined\n                    ? '.'\n                    : translateStrand[val + 1] || val;\n        }\n        else {\n            fields[i] =\n                val === null || val === undefined ? '.' : escapeColumn(String(val));\n        }\n    }\n    fields[8] = attrString;\n    const formattedString = `${fields.join('\\t')}\\n`;\n    // if we have already output this exact feature, skip it\n    if (seenFeature[formattedString]) {\n        return '';\n    }\n    // eslint-disable-next-line no-param-reassign\n    seenFeature[formattedString] = true;\n    return formattedString;\n}\nfunction _formatFeature(feature, seenFeature) {\n    if (Array.isArray(feature)) {\n        return feature.map(f => _formatFeature(f, seenFeature)).join('');\n    }\n    const strings = [_formatSingleFeature(feature, seenFeature)];\n    ['child_features', 'derived_features'].forEach(multiSlot => {\n        if (feature[multiSlot]) {\n            strings.push(...feature[multiSlot].map(f => _formatFeature(f, seenFeature)));\n        }\n    });\n    return strings.join('');\n}\n/**\n * Format a feature object or array of\n * feature objects into one or more lines of GTF.\n *\n * @param {Object|Array[Object]} featureOrFeatures\n */\nexport function formatFeature(featureOrFeatures) {\n    const seen = {};\n    return _formatFeature(featureOrFeatures, seen);\n}\n/**\n * Format a directive into a line of GTF.\n *\n * @param {Object} directive\n * @returns {String}\n */\nexport function formatDirective(directive) {\n    let str = `##${directive.directive}`;\n    if (directive.value) {\n        str += ` ${directive.value}`;\n    }\n    str += '\\n';\n    return str;\n}\n/**\n * Format a comment into a GTF comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param {Object} comment\n * @returns {String}\n */\nexport function formatComment(comment) {\n    return `# ${comment.comment}\\n`;\n}\n/**\n * Format a sequence object as FASTA\n *\n * @param {Object} seq\n * @returns {String} formatted single FASTA sequence\n */\nexport function formatSequence(seq) {\n    return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${seq.sequence}\\n`;\n}\n/**\n * Format a directive, comment, or feature,\n * or array of such items, into one or more lines of GTF.\n *\n * @param {Object|Array} itemOrItems\n */\nexport function formatItem(itemOrItems) {\n    function formatSingleItem(item) {\n        if (item[0] || item.attributes) {\n            return formatFeature(item);\n        }\n        if (item.directive) {\n            return formatDirective(item);\n        }\n        if (item.sequence) {\n            return formatSequence(item);\n        }\n        if (item.comment) {\n            return formatComment(item);\n        }\n        return '# (invalid item found during format)\\n';\n    }\n    if (Array.isArray(itemOrItems)) {\n        return itemOrItems.map(item => formatSingleItem(item));\n    }\n    return formatSingleItem(itemOrItems);\n}\n//# sourceMappingURL=util.js.map","//@ts-nocheck\nimport * as GTF from './util';\nconst containerAttributes = {\n    Parent: 'child_features',\n    Derives_from: 'derived_features',\n};\nexport default class Parser {\n    constructor(args) {\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        const nullFunc = () => { };\n        Object.assign(this, {\n            featureCallback: args.featureCallback || nullFunc,\n            endCallback: args.endCallback || nullFunc,\n            commentCallback: args.commentCallback || nullFunc,\n            errorCallback: args.errorCallback || nullFunc,\n            directiveCallback: args.directiveCallback || nullFunc,\n            sequenceCallback: args.sequenceCallback || nullFunc,\n            // number of lines to buffer\n            bufferSize: args.bufferSize === undefined ? 1000 : args.bufferSize,\n            // features that we have to keep on hand for now because they\n            // might be referenced by something else\n            _underConstructionTopLevel: [],\n            // index of the above by ID\n            _underConstructionById: {},\n            _completedReferences: {},\n            // features that reference something we have not seen yet\n            // structured as:\n            // {  'some_id' : {\n            //     'Parent' : [ orphans that have a Parent attr referencing it ],\n            //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n            //    }\n            // }\n            _underConstructionOrphans: {},\n            // if this is true, the parser ignores the\n            // rest of the lines in the file.\n            eof: false,\n            lineNumber: 0,\n        });\n    }\n    addLine(line) {\n        if (this.eof) {\n            // otherwise, if we are done, ignore this line\n            return;\n        }\n        this.lineNumber += 1;\n        if (/^\\s*[^#\\s>]/.test(line)) {\n            // feature line, most common case\n            this._bufferLine(line);\n            return;\n        }\n        const match = /^\\s*(#+)(.*)/.exec(line);\n        if (match) {\n            // directive or comment\n            // eslint-disable-next-line prefer-const\n            let [, hashsigns, contents] = match;\n            if (hashsigns.length === 3) {\n                // sync directive, all forward-references are resolved.\n                this._emitAllUnderConstructionFeatures();\n            }\n            else if (hashsigns.length === 2) {\n                const directive = GTF.parseDirective(line);\n                this._emitItem(directive);\n            }\n            else {\n                contents = contents.replace(/\\s*/, '');\n                this._emitItem({ comment: contents });\n            }\n        }\n        else if (/^\\s*$/.test(line)) {\n            // blank line, do nothing\n        }\n        else {\n            // it's a parse error\n            const errLine = line.replace(/\\r?\\n?$/g, '');\n            throw new Error(`GTF parse error.  Cannot parse '${errLine}'.`);\n        }\n    }\n    _emitItem(i) {\n        if (i[0]) {\n            this.featureCallback(i);\n        }\n        else if (i.directive) {\n            this.directiveCallback(i);\n        }\n        else if (i.comment) {\n            this.commentCallback(i);\n        }\n    }\n    finish() {\n        this._emitAllUnderConstructionFeatures();\n        this.endCallback();\n    }\n    _enforceBufferSizeLimit(additionalItemCount = 0) {\n        const _unbufferItem = item => {\n            var _a, _b, _c;\n            if ((_c = (_b = (_a = item === null || item === void 0 ? void 0 : item[0]) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.ID) === null || _c === void 0 ? void 0 : _c[0]) {\n                const ids = item[0].attributes.ID;\n                ids.forEach(id => {\n                    delete this._underConstructionById[id];\n                    delete this._completedReferences[id];\n                });\n                item.forEach(i => {\n                    if (i.child_features) {\n                        i.child_features.forEach(c => { _unbufferItem(c); });\n                    }\n                    if (i.derived_features) {\n                        i.derived_features.forEach(d => { _unbufferItem(d); });\n                    }\n                });\n            }\n        };\n        while (this._underConstructionTopLevel.length + additionalItemCount >\n            this.bufferSize) {\n            const item = this._underConstructionTopLevel.shift();\n            this._emitItem(item);\n            _unbufferItem(item);\n        }\n    }\n    /**\n     * return all under-construction features, called when we know\n     * there will be no additional data to attach to them\n     * @private\n     */\n    _emitAllUnderConstructionFeatures() {\n        this._underConstructionTopLevel.forEach(this._emitItem.bind(this));\n        this._underConstructionTopLevel = [];\n        this._underConstructionById = {};\n        this._completedReferences = {};\n        // if we have any orphans hanging around still, this is a\n        // problem. die with a parse error\n        if (Object.values(this._underConstructionOrphans).filter(entry => Object.keys(entry).length).length) {\n            throw new Error(`some features reference other features that do not exist in the file (or in the same '###' scope). ${JSON.stringify(this._underConstructionOrphans)}`);\n        }\n    }\n    // do the right thing with a newly-parsed feature line\n    _bufferLine(line) {\n        const featureLine = GTF.parseFeature(line);\n        featureLine.child_features = [];\n        featureLine.derived_features = [];\n        // featureLine._lineNumber = this.lineNumber //< debugging aid\n        const featureNumber = this.lineNumber; // no such thing as unique ID in GTF. make one up.\n        const isTranscript = featureLine.featureType === 'transcript'; // trying to support the Cufflinks convention of adding a transcript line\n        // NOTE: a feature is an arrayref of one or more feature lines.\n        const ids = isTranscript\n            ? featureLine.attributes.transcript_id || []\n            : [featureNumber];\n        const parents = isTranscript\n            ? []\n            : featureLine.attributes.transcript_id || [];\n        const derives = featureLine.attributes.Derives_from || [];\n        if (!ids.length && !parents.length && !derives.length) {\n            // if it has no IDs and does not refer to anything, we can just\n            // output it\n            this._emitItem([featureLine]);\n            return;\n        }\n        function createTranscript(feature) {\n            const result = JSON.parse(JSON.stringify(feature));\n            result.featureType = 'transcript';\n            return GTF.formatFeature(result);\n        }\n        parents.forEach(parent => {\n            const underConst = this._underConstructionById[parent];\n            if (!underConst) {\n                this._bufferLine(createTranscript(featureLine));\n            }\n        });\n        let feature;\n        ids.forEach(id => {\n            const existing = this._underConstructionById[id];\n            if (existing) {\n                existing.push(featureLine);\n                feature = existing;\n            }\n            else {\n                // haven't seen it yet, so buffer it so we can attach\n                // child features to it\n                feature = [featureLine];\n                this._enforceBufferSizeLimit(1);\n                if (!parents.length && !derives.length) {\n                    this._underConstructionTopLevel.push(feature);\n                }\n                this._underConstructionById[id] = feature;\n                // see if we have anything buffered that refers to it\n                this._resolveReferencesTo(feature, id);\n            }\n        });\n        // try to resolve all its references\n        this._resolveReferencesFrom(feature || [featureLine], { Parent: parents, Derives_from: derives }, ids);\n    }\n    _resolveReferencesTo(feature, id) {\n        const references = this._underConstructionOrphans[id];\n        if (!references) {\n            return;\n        }\n        Object.keys(references).forEach(attrname => {\n            const pname = containerAttributes[attrname] || attrname.toLowerCase();\n            feature.forEach(loc => {\n                loc[pname].push(...references[attrname]);\n                delete references[attrname];\n            });\n        });\n    }\n    _parseError(message) {\n        this.eof = true;\n        this.errorCallback(`${this.lineNumber}: ${message}`);\n    }\n    _resolveReferencesFrom(feature, references, ids) {\n        // this is all a bit more awkward in javascript than it was in perl\n        function postSet(obj, slot1, slot2) {\n            let subObj = obj[slot1];\n            if (!subObj) {\n                subObj = {};\n                obj[slot1] = subObj;\n            }\n            const returnVal = subObj[slot2] || false;\n            subObj[slot2] = true;\n            return returnVal;\n        }\n        function expandFeature(parentFeature, childFeature) {\n            parentFeature[0].start = Math.min(parentFeature[0].start, childFeature[0].start);\n            parentFeature[0].end = Math.max(parentFeature[0].end, childFeature[0].end);\n        }\n        Object.entries(references).forEach(([attrname, toIds]) => {\n            let pname;\n            toIds.forEach(toId => {\n                const otherFeature = this._underConstructionById[toId];\n                if (otherFeature) {\n                    expandFeature(otherFeature, feature);\n                    if (!pname) {\n                        pname = containerAttributes[attrname] || attrname.toLowerCase();\n                    }\n                    if (!ids.filter(id => postSet(this._completedReferences, id, `${attrname},${toId}`)).length) {\n                        otherFeature.forEach(location => {\n                            location[pname].push(feature);\n                        });\n                    }\n                }\n                else {\n                    if (!this._underConstructionOrphans[toId]) {\n                        this._underConstructionOrphans[toId] = {};\n                    }\n                    if (!this._underConstructionOrphans[toId][attrname]) {\n                        this._underConstructionOrphans[toId][attrname] = [];\n                    }\n                    this._underConstructionOrphans[toId][attrname].push(feature);\n                }\n            });\n        });\n    }\n}\n//# sourceMappingURL=parse.js.map","import Parser from './parse';\nexport function parseStringSync(str) {\n    if (!str) {\n        return [];\n    }\n    const items = [];\n    const parser = new Parser({\n        // @ts-expect-error\n        featureCallback: item => items.push(item),\n        // @ts-expect-error\n        errorCallback: err => {\n            throw err;\n        },\n    });\n    for (const line of str.split(/\\r?\\n/)) {\n        parser.addLine(line);\n    }\n    parser.finish();\n    return items;\n}\n//# sourceMappingURL=api.js.map","export function featureData(data, id) {\n    const f = { ...data };\n    f.start -= 1;\n    f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[data.strand];\n    f.phase = Number(data.frame);\n    f.refName = data.seq_name;\n    if (data.score === null) {\n        f.score = undefined;\n    }\n    if (data.frame === null) {\n        f.score = undefined;\n    }\n    const defaultFields = new Set([\n        'start',\n        'end',\n        'seq_name',\n        'score',\n        'featureType',\n        'source',\n        'frame',\n        'strand',\n    ]);\n    for (const a of Object.keys(data.attributes)) {\n        let b = a.toLowerCase();\n        if (defaultFields.has(b)) {\n            b += '2';\n        }\n        if (data.attributes[a]) {\n            let attr = data.attributes[a];\n            if (Array.isArray(attr) && attr.length === 1) {\n                attr = attr[0].replaceAll(/^\"|\"$/g, '');\n            }\n            f[b] = attr;\n        }\n    }\n    f.refName = f.seq_name;\n    f.type = f.featureType;\n    if (data.child_features && data.child_features.length > 0) {\n        f.subfeatures = data.child_features.flatMap(childLocs => childLocs.map(childLoc => featureData(childLoc)));\n    }\n    f.child_features = undefined;\n    f.data = undefined;\n    f.derived_features = undefined;\n    f._linehash = undefined;\n    f.attributes = undefined;\n    f.seq_name = undefined;\n    f.featureType = undefined;\n    f.frame = undefined;\n    if (f.transcript_id) {\n        f.name = f.transcript_id;\n    }\n    if (id !== undefined) {\n        f.uniqueId = id;\n    }\n    return f;\n}\n","import IntervalTree from '@flatten-js/interval-tree';\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';\nimport { SimpleFeature, doesIntersect2, fetchAndMaybeUnzip, getProgressDisplayStr, max, min, } from '@jbrowse/core/util';\nimport { openLocation } from '@jbrowse/core/util/io';\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs';\nimport { parseStringSync } from 'gtf-nostream';\nimport { featureData } from '../util';\nexport default class GtfAdapter extends BaseFeatureDataAdapter {\n    constructor() {\n        super(...arguments);\n        this.calculatedIntervalTreeMap = {};\n    }\n    async loadDataP(opts) {\n        const { statusCallback = () => { } } = opts || {};\n        const loc = openLocation(this.getConf('gtfLocation'), this.pluginManager);\n        const buffer = await fetchAndMaybeUnzip(loc, opts);\n        const headerLines = [];\n        const featureMap = {};\n        let blockStart = 0;\n        let i = 0;\n        const decoder = new TextDecoder('utf8');\n        while (blockStart < buffer.length) {\n            const n = buffer.indexOf(10, blockStart);\n            const b = n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n);\n            const line = decoder.decode(b).trim();\n            if (line) {\n                if (line.startsWith('#')) {\n                    headerLines.push(line);\n                }\n                else if (line.startsWith('>')) {\n                    break;\n                }\n                else {\n                    const ret = line.indexOf('\\t');\n                    const refName = line.slice(0, ret);\n                    if (!featureMap[refName]) {\n                        featureMap[refName] = '';\n                    }\n                    featureMap[refName] += `${line}\\n`;\n                }\n            }\n            if (i++ % 10000 === 0) {\n                statusCallback(`Loading ${getProgressDisplayStr(blockStart, buffer.length)}`);\n            }\n            blockStart = n + 1;\n        }\n        const intervalTreeMap = Object.fromEntries(Object.entries(featureMap).map(([refName, lines]) => [\n            refName,\n            (sc) => {\n                if (!this.calculatedIntervalTreeMap[refName]) {\n                    sc === null || sc === void 0 ? void 0 : sc('Parsing GTF data');\n                    const intervalTree = new IntervalTree();\n                    for (const obj of parseStringSync(lines)\n                        .flat()\n                        .map((f, i) => featureData(f, `${this.id}-${refName}-${i}`))) {\n                        intervalTree.insert([obj.start, obj.end], obj);\n                    }\n                    this.calculatedIntervalTreeMap[refName] = intervalTree;\n                }\n                return this.calculatedIntervalTreeMap[refName];\n            },\n        ]));\n        return {\n            header: headerLines.join('\\n'),\n            intervalTreeMap,\n        };\n    }\n    async loadData(opts = {}) {\n        if (!this.gtfFeatures) {\n            this.gtfFeatures = this.loadDataP(opts).catch((e) => {\n                this.gtfFeatures = undefined;\n                throw e;\n            });\n        }\n        return this.gtfFeatures;\n    }\n    async getRefNames(opts = {}) {\n        const { intervalTreeMap } = await this.loadData(opts);\n        return Object.keys(intervalTreeMap);\n    }\n    async getHeader(opts = {}) {\n        const { header } = await this.loadData(opts);\n        return header;\n    }\n    getFeatures(query, opts = {}) {\n        return ObservableCreate(async (observer) => {\n            try {\n                await this.getFeaturesHelper({\n                    query,\n                    opts,\n                    observer,\n                    allowRedispatch: true,\n                });\n            }\n            catch (e) {\n                observer.error(e);\n            }\n        }, opts.stopToken);\n    }\n    async getFeaturesHelper({ query, opts, observer, allowRedispatch, originalQuery = query, }) {\n        var _a;\n        const aggregateField = this.getConf('aggregateField');\n        const { start, end, refName } = query;\n        const { intervalTreeMap } = await this.loadData(opts);\n        const feats = (_a = intervalTreeMap[refName]) === null || _a === void 0 ? void 0 : _a.call(intervalTreeMap, opts.statusCallback).search([\n            start,\n            end,\n        ]);\n        if (feats) {\n            if (allowRedispatch && feats.length) {\n                let minStart = Number.POSITIVE_INFINITY;\n                let maxEnd = Number.NEGATIVE_INFINITY;\n                let hasAnyAggregateField = false;\n                for (const feat of feats) {\n                    if (feat.start < minStart) {\n                        minStart = feat.start;\n                    }\n                    if (feat.end > maxEnd) {\n                        maxEnd = feat.end;\n                    }\n                    if (feat[aggregateField]) {\n                        hasAnyAggregateField = true;\n                    }\n                }\n                if (hasAnyAggregateField &&\n                    (maxEnd > query.end || minStart < query.start)) {\n                    await this.getFeaturesHelper({\n                        query: {\n                            ...query,\n                            start: minStart - 500000,\n                            end: maxEnd + 500000,\n                        },\n                        opts,\n                        observer,\n                        allowRedispatch: false,\n                        originalQuery: query,\n                    });\n                    return;\n                }\n            }\n            const parentAggregation = {};\n            if (feats.some(f => f.uniqueId === undefined)) {\n                throw new Error('found uniqueId undefined');\n            }\n            for (const feat of feats) {\n                const aggr = feat[aggregateField];\n                if (!parentAggregation[aggr]) {\n                    parentAggregation[aggr] = [];\n                }\n                if (aggr) {\n                    parentAggregation[aggr].push(feat);\n                }\n                else {\n                    observer.next(new SimpleFeature({\n                        id: feat.uniqueId,\n                        data: feat,\n                    }));\n                }\n            }\n            for (const [name, subfeatures] of Object.entries(parentAggregation)) {\n                const s = min(subfeatures.map(f => f.start));\n                const e = max(subfeatures.map(f => f.end));\n                if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n                    const { uniqueId, strand } = subfeatures[0];\n                    observer.next(new SimpleFeature({\n                        id: `${uniqueId}-parent`,\n                        data: {\n                            type: 'gene',\n                            subfeatures,\n                            strand,\n                            name,\n                            start: s,\n                            end: e,\n                            refName: query.refName,\n                        },\n                    }));\n                }\n            }\n        }\n        observer.complete();\n    }\n}\n"],"names":["fieldNames","unescape","s","_","seq","_escape","regex","ch","hex","escape","escapeColumn","parseAttributes","attrString","attrs","attribute","attr","arec","parseFeature","line","f","a","parsed","i","parseDirective","match","name","contents","seqId","contentStart","contentEnd","source","buildname","formatAttributes","attrOrder","tag","val","valstring","translateStrand","_formatSingleFeature","seenFeature","fields","formattedString","_formatFeature","feature","strings","multiSlot","formatFeature","featureOrFeatures","containerAttributes","Parser","args","nullFunc","hashsigns","directive","GTF.parseDirective","errLine","additionalItemCount","_unbufferItem","item","_a","_b","_c","id","c","d","entry","featureLine","GTF.parseFeature","featureNumber","isTranscript","ids","parents","derives","createTranscript","result","GTF.formatFeature","parent","existing","references","attrname","pname","loc","message","postSet","obj","slot1","slot2","subObj","returnVal","expandFeature","parentFeature","childFeature","toIds","toId","otherFeature","location","parseStringSync","str","items","parser","err","featureData","data","defaultFields","b","childLocs","childLoc","GtfAdapter","BaseFeatureDataAdapter","opts","statusCallback","openLocation","buffer","fetchAndMaybeUnzip","headerLines","featureMap","blockStart","decoder","n","ret","refName","getProgressDisplayStr","intervalTreeMap","lines","sc","intervalTree","IntervalTree","header","query","ObservableCreate","observer","e","allowRedispatch","originalQuery","aggregateField","start","end","feats","minStart","maxEnd","hasAnyAggregateField","feat","parentAggregation","aggr","SimpleFeature","subfeatures","min","max","doesIntersect2","uniqueId","strand"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}